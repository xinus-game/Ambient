<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ambient Documentation</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="user/installing.html"><strong aria-hidden="true">1.</strong> Installing</a></li><li class="chapter-item expanded "><a href="user/setting_up_ide.html"><strong aria-hidden="true">2.</strong> Setting up your IDE</a></li><li class="chapter-item expanded "><a href="user/overview.html"><strong aria-hidden="true">3.</strong> Overview</a></li><li class="chapter-item expanded "><a href="user/getting_started.html"><strong aria-hidden="true">4.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="user/running_examples.html"><strong aria-hidden="true">5.</strong> Running examples</a></li><li class="chapter-item expanded "><a href="user/api.html"><strong aria-hidden="true">6.</strong> API</a></li><li class="chapter-item expanded "><a href="user/debugging.html"><strong aria-hidden="true">7.</strong> Debugging</a></li><li class="chapter-item expanded "><a href="user/profiling.html"><strong aria-hidden="true">8.</strong> Profiling</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference Guide</li><li class="chapter-item expanded "><a href="reference/getting_content.html"><strong aria-hidden="true">9.</strong> Getting content</a></li><li class="chapter-item expanded "><a href="reference/runtime.html"><strong aria-hidden="true">10.</strong> Runtime</a></li><li class="chapter-item expanded "><a href="reference/ember.html"><strong aria-hidden="true">11.</strong> Ember</a></li><li class="chapter-item expanded "><a href="reference/ecs.html"><strong aria-hidden="true">12.</strong> ECS</a></li><li class="chapter-item expanded "><a href="reference/models.html"><strong aria-hidden="true">13.</strong> Models</a></li><li class="chapter-item expanded "><a href="reference/hierarchies.html"><strong aria-hidden="true">14.</strong> Hierarchies and transforms</a></li><li class="chapter-item expanded "><a href="reference/asset_pipeline.html"><strong aria-hidden="true">15.</strong> Asset pipeline</a></li><li class="chapter-item expanded "><a href="reference/networking.html"><strong aria-hidden="true">16.</strong> Networking</a></li><li class="chapter-item expanded "><a href="reference/animations.html"><strong aria-hidden="true">17.</strong> Animations</a></li><li class="chapter-item expanded "><a href="reference/audio.html"><strong aria-hidden="true">18.</strong> Audio</a></li><li class="chapter-item expanded "><a href="reference/ui.html"><strong aria-hidden="true">19.</strong> UI</a></li><li class="chapter-item expanded "><a href="reference/terminology.html"><strong aria-hidden="true">20.</strong> Terminology</a></li><li class="chapter-item expanded "><a href="reference/common_pitfalls.html"><strong aria-hidden="true">21.</strong> Common pitfalls</a></li><li class="chapter-item expanded "><a href="reference/faq.html"><strong aria-hidden="true">22.</strong> FAQ</a></li><li class="chapter-item expanded affix "><li class="part-title">Community</li><li class="chapter-item expanded "><a href="community/contributing.html"><strong aria-hidden="true">23.</strong> Contributing</a></li><li class="chapter-item expanded "><a href="community/changelog.html"><strong aria-hidden="true">24.</strong> Changelog</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Ambient Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Ambient is a runtime for building high-performance multiplayer games and 3D applications, powered by WebAssembly, Rust and WebGPU.</p>
<p>See our <a href="https://www.ambient.run/post/introducing-ambient">announcement blog post</a> for more details.</p>
<h2 id="design-principles"><a class="header" href="#design-principles">Design principles</a></h2>
<ul>
<li><strong>Seamless networking</strong>: Ambient is both your server and client. All you need to do is to build your server and/or client-side logic: the runtime handles synchronization of data for you.</li>
<li><strong>Isolation</strong>: Projects you build for Ambient are executed in isolation through the power of <a href="https://webassembly.org/">WebAssembly</a> - so that if something crashes, it won’t take down your entire program. It also means that you can run untrusted code safely.</li>
<li><strong>Data-oriented design</strong>: The core data model of Ambient is an <a href="https://en.wikipedia.org/wiki/Entity_component_system">entity component system</a> which each WASM module can manipulate.</li>
<li><strong>Language-agnostic</strong>: You will be able to build Ambient modules in any language that can compile to WebAssembly. At present, Rust is the only supported language, but we are working on expanding to other languages.</li>
<li><strong>Single executable</strong>: Ambient is a single executable which can run on Windows, Mac and Linux. It can act as a server or as a client.</li>
<li><strong>Interoperability</strong>: Ambient allows you to define custom components and &quot;concepts&quot; (collections of components). As long as your Ambient projects use the same components and concepts, they will be able to share data and interoperate, even if they have no awareness of each other.</li>
<li><strong>Asset pipeline and streaming</strong>: Ambient has an <a href="https://ambientrun.github.io/Ambient/reference/asset_pipeline.html">asset pipeline</a> that is capable of compiling multiple asset formats, including <code>.glb</code> and <code>.fbx</code>. The assets are always streamed over the network, so your clients will receive everything they need when they join.</li>
<li><strong>Powerful renderer</strong>: The Ambient renderer is GPU-driven, with both culling and level-of-detail switching being handled entirely by the GPU. By default, it uses <a href="https://en.wikipedia.org/wiki/Physically_based_rendering">PBR</a>. It also supports cascading shadow maps and instances everything that can be instanced.</li>
</ul>
<p>See the <a href="https://ambientrun.github.io/Ambient/">documentation</a> for a guide on how to get started, or browse the <code>guest/rust/examples</code> for the version of Ambient you're using. The <code>main</code> branch is a development branch and is likely incompatible with the latest released version of Ambient.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing"><a class="header" href="#installing">Installing</a></h1>
<p>The easiest way to install Ambient is to download the latest binary release from the <a href="https://github.com/AmbientRun/Ambient/releases">GitHub releases</a>.
Currently, there are builds for Windows x64, Linux x64, and Mac ARM64. For other platforms, use the <a href="user/installing.html#installing-from-git">installing from Git</a> method.</p>
<p>You will also need <a href="https://www.rust-lang.org/">Rust</a> installed with the <code>wasm32-wasi</code> toolchain so that you can compile Ambient modules.
Note that Ambient compiles Rust code with stable Rust, so you must make sure that <code>wasm32-wasi</code> is installed for <code>stable</code>:</p>
<pre><code class="language-sh">rustup target add --toolchain stable wasm32-wasi
</code></pre>
<h2 id="installing-from-git"><a class="header" href="#installing-from-git">Installing from Git</a></h2>
<p>Ambient can be installed through <code>cargo install</code>.</p>
<p>This will automatically download the source, compile and install Ambient from your system. Our minimum supported Rust version is <!-- rust-version-begin -->1.67.0<!-- rust-version-end -->.</p>
<h3 id="installing-the-latest-published-release"><a class="header" href="#installing-the-latest-published-release">Installing the latest published release</a></h3>
<p>This is the recommended method of installing Ambient from source if the downloadable binaries are insufficient. The latest published release should be used unless you have a specific reason to use the development version.</p>
<pre><code class="language-sh">cargo install --git https://github.com/AmbientRun/Ambient.git --tag v0.2.1 --locked --force ambient
</code></pre>
<h3 id="installing-the-latest-development-version"><a class="header" href="#installing-the-latest-development-version">Installing the latest development version</a></h3>
<p>Ambient is actively developed on the <code>main</code> branch of the repository. This branch contains in-development changes, including new features, bug fixes and breaking changes. This method can be used if you would like to try out these changes.</p>
<p><strong>Note</strong>: The <code>main</code> branch is subject to frequent breaking changes, including potential new bugs and decreased stability, and is not a stable development target for projects. Using the <code>main</code> branch is not recommended if you are unable to actively update your project to accommodate breaking changes.</p>
<pre><code class="language-sh">cargo install --git https://github.com/AmbientRun/Ambient.git --locked --force ambient
</code></pre>
<p><strong>Note</strong>: If you are running a project outside of the <code>guest/rust</code> workspace, it is likely that the published version of the API will be incompatible with <code>main</code>, and you will need to specify the dependency manually.</p>
<p>Additionally, the <code>--locked</code> flag is recommended to ensure that the correct packages are installed and that the build is reproducible between machines.</p>
<h3 id="optional-features"><a class="header" href="#optional-features">Optional features</a></h3>
<p>You can supply these feature flags to get optional features that are disabled by default:</p>
<pre><code class="language-sh">cargo install --git https://github.com/AmbientRun/Ambient.git ambient --features assimp --locked --force
</code></pre>
<ul>
<li><code>assimp</code>: This adds support for <a href="https://github.com/assimp/assimp">assimp</a>, which loads ~40 additional model file formats, such as <code>obj</code>, text-based <code>fbx</code> and much more</li>
</ul>
<h3 id="build-dependencies-linuxubuntu"><a class="header" href="#build-dependencies-linuxubuntu">Build dependencies: Linux/Ubuntu</a></h3>
<p>For the above to work on Linux, you also need to install the following build dependencies:</p>
<pre><code class="language-sh">apt-get install -y \
    build-essential cmake pkg-config \
    libfontconfig1-dev clang libasound2-dev ninja-build
</code></pre>
<h2 id="installing-via-asdf-linux-macos"><a class="header" href="#installing-via-asdf-linux-macos">Installing via asdf (Linux, Macos)</a></h2>
<p>Thanks to <a href="https://github.com/jtakakura">@jtakakura</a>, Ambient can also be installed using <a href="https://asdf-vm.com/">asdf</a> by running <code>asdf plugin add ambient</code>. For more details, visit <a href="https://github.com/jtakakura/asdf-ambient">https://github.com/jtakakura/asdf-ambient</a>.</p>
<h2 id="running-on-headless-linuxubuntu"><a class="header" href="#running-on-headless-linuxubuntu">Running on headless Linux/Ubuntu</a></h2>
<p>To run on a headless Linux machine, install the following dependencies in addition to the dependencies specified above:</p>
<pre><code class="language-sh">add-apt-repository ppa:oibaf/graphics-drivers -y
apt-get update
apt install -y libxcb-xfixes0-dev mesa-vulkan-drivers
</code></pre>
<p>Ambient currently assumes that you have access to GPU drivers (but not necessarily a GPU) in headless mode. This requirement may be relaxed in future.</p>
<h2 id="dockerfile"><a class="header" href="#dockerfile">Dockerfile</a></h2>
<p>A <code>Dockerfile</code> is also provided that provides a headless Debian environment with all of the dependencies required to run Ambient as a server. This Dockerfile is intended for development, not production, so it has more dependencies than are strictly required to run Ambient.</p>
<p>To build the Dockerfile:</p>
<pre><code class="language-sh">docker build -t ambient .
</code></pre>
<p>To run the Dockerfile with <code>bash</code> in the current directory:</p>
<pre><code class="language-sh">docker run --rm -it -e bash -v &quot;$(pwd)&quot;:/app ambient
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-your-ide"><a class="header" href="#setting-up-your-ide">Setting up your IDE</a></h1>
<p>Our recommended IDE is Visual Studio Code (VSCode).</p>
<h2 id="visual-studio-code-vscode"><a class="header" href="#visual-studio-code-vscode">Visual Studio Code (VSCode)</a></h2>
<p>Install <a href="https://code.visualstudio.com/">Visual Studio Code</a>, then install the following plugins:</p>
<ul>
<li><a href="https://rust-analyzer.github.io/">rust-analyzer</a>, as described <a href="https://code.visualstudio.com/docs/languages/rust">here</a>.</li>
<li><a href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">CodeLLDB</a>. This one is optional, but with it you can launch your ember from with VSCode by pressing F5.</li>
</ul>
<p><code>ambient new</code> will set up your ember for VSCode by default, by creating a <code>.vscode/settings.json</code> for you.</p>
<h2 id="emacs"><a class="header" href="#emacs">Emacs</a></h2>
<p>There are multiple ways to configure Emacs as a Rust IDE. The following assumes you are using <a href="https://github.com/brotzeit/rustic">rustic</a>,
<a href="https://github.com/emacs-lsp/lsp-mode">lsp-mode</a> and <a href="https://rust-analyzer.github.io/">rust-analyzer</a> libraries. <a href="https://robert.kra.hn/posts/rust-emacs-setup/#prerequisites">Robert Krahn provides a comprehensive guide to configuring Emacs for Rust development</a></p>
<p>Once you have Emacs configured for general Rust development, you need to set some explicit values for Ambient embers. Ambient uses some custom <code>cargo</code> configuration values that Emacs and rust-analyzer need to know about. You can manually set these variables with the following <code>elisp</code>:</p>
<pre><code class="language-elisp">  (setq lsp-rust-analyzer-cargo-target &quot;wasm32-wasi&quot;
        lsp-rust-analyzer-cargo-watch-args [&quot;--features&quot; &quot;client server&quot;]
        lsp-rust-features [&quot;client&quot; &quot;server&quot;])
</code></pre>
<p>Furthermore, you can add a <code>.dir-locals.el</code> file to your Ambient ember directory that Emacs will pick up and load settings for. This is similar to the <code>.vscode/settings.json</code> that is created by default. This is an example <code>.dir-locals.el</code> file:</p>
<pre><code class="language-elisp">((rustic-mode . ((eval . (setq-local lsp-rust-analyzer-cargo-target &quot;wasm32-wasi&quot;))
                 (eval . (setq-local lsp-rust-analyzer-cargo-watch-args [&quot;--features&quot; &quot;client server&quot;]))
                 (eval . (setq-local lsp-rust-features [&quot;client&quot; &quot;server&quot;])))))
</code></pre>
<h2 id="other-ides"><a class="header" href="#other-ides">Other IDEs</a></h2>
<p>To get rust-analyzer to work, you need to make sure it's building with the <code>server</code> and <code>client</code> feature flags enabled. See <a href="https://github.com/AmbientRun/Ambient/blob/main/app/src/cli/new_project_template/.vscode/settings.json">.vscode/settings.json</a> for an example.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-of-ambient"><a class="header" href="#overview-of-ambient">Overview of Ambient</a></h1>
<p>Let's start with a rough overview of Ambient to give you an idea of how it works.</p>
<h2 id="the-database-ecs"><a class="header" href="#the-database-ecs">The database (ECS)</a></h2>
<p>The most central thing in Ambient is the <a href="user/../reference/ecs.html">ECS</a> &quot;world&quot;. You can think of it
as a database that stores everything in your application.</p>
<p>The world is a collection of entities. An entity is a collection of components and a component is a
<code>(name, value)</code> pair. For example, you could have an entity with two components:</p>
<pre><code class="language-yml">entity 1932:
  - translation: (5, 2, 0)
  - color: (1, 0, 0, 1)
</code></pre>
<p>If you compare this to a traditional SQL database, you can think of entities as rows and
components as columns. Note that there is no equivalent of a table, though: any component can be attached to any
entity.</p>
<h2 id="clientserver"><a class="header" href="#clientserver">Client/server</a></h2>
<p>The next thing to know is that Ambient is built around a client/server architecture. Both
the server and the client have a world of their own (green and blue boxes in the image below).</p>
<p><img src="user/server_client.png" alt="Server client architecture" /></p>
<p>The server's world is automatically replicated to all clients' worlds. The clients can
add additional entities and/or components to their local world. Typically, you'll
have game state on the server (for instance <code>{ unit: &quot;orc&quot;, level: 10 }</code>), and visual
effects or other client-local state on the clients (for instance, spawn fireworks when
the orc levels up).</p>
<p>Note that the replication is one-way.
Any changes you make to your client world will <em>not</em> be replicated to the server.
To communicate from the client to the server, you will typically use <a href="user/../reference/networking.html#messaging">message passing</a> instead.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>Ambient projects are called <em>embers</em>. An ember is a collection of code, assets, and configuration that can be run in Ambient. They can be combined with other embers to create a game.</p>
<h2 id="creating-a-ember"><a class="header" href="#creating-a-ember">Creating a ember</a></h2>
<p>To create a ember, run:</p>
<pre><code class="language-sh">ambient new my-ember
</code></pre>
<p>This will generate a new ember with a simple Rust module and an Ambient ember manifest.</p>
<h2 id="running-a-ember"><a class="header" href="#running-a-ember">Running a ember</a></h2>
<p>This ember can be run:</p>
<pre><code class="language-sh">cd my-ember
ambient run
</code></pre>
<p>From here on, you can open up the ember in your favorite IDE and start editing the code. If you need a recommendation for an IDE, see <a href="user/./setting_up_ide.html">Setting up your IDE</a>. If using VS Code, the ember can be launched with the system-installed Ambient using the <code>F5</code>/Debug button, which is preconfigured to run the current ember.</p>
<p>For more details about the API, see <a href="user/./api.html">API</a>.</p>
<h2 id="multiplayer"><a class="header" href="#multiplayer">Multiplayer</a></h2>
<p>Every Ambient ember is multiplayer by default. To start the ember in server-only mode, use the following command:</p>
<pre><code class="language-sh">ambient serve
</code></pre>
<p>This will output a line which looks like this:</p>
<pre><code class="language-sh">[2023-04-13T09:05:42Z INFO  ambient_network::server] Proxy allocated an endpoint, use `ambient join proxy-eu.ambient.run:9898` to join
</code></pre>
<p>The server can now be connected to by anywhere on the internet (it's proxied by default), using the provided command:</p>
<pre><code class="language-sh">ambient join proxy-eu.ambient.run:9898
</code></pre>
<p>Ambient always streams all assets, so the only thing anyone needs to connect to your server is Ambient itself. Try sending the command
to a friend, and play your game together!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-examples"><a class="header" href="#running-examples">Running examples</a></h1>
<p>You can either run the examples from the latest released version of Ambient, or with the development <code>main</code> branch.</p>
<p>However, <strong>the version of Ambient must match the version that the examples were built for</strong>. For instance, if you are running the <code>main</code> branch of Ambient, you must also run the <code>main</code> branch of the examples.</p>
<h2 id="running-examples-from-the-latest-release"><a class="header" href="#running-examples-from-the-latest-release">Running examples from the latest release</a></h2>
<ol>
<li>Download the Ambient executable from the <a href="https://github.com/AmbientRun/Ambient/releases">releases page</a>.</li>
<li>Download the <code>examples.zip</code> file from the same page.</li>
<li>Extract both, and use the extracted Ambient to run the examples: <code>./ambient run examples/basics/primitives</code></li>
</ol>
<h2 id="running-examples-from-main"><a class="header" href="#running-examples-from-main">Running examples from main</a></h2>
<ol>
<li>Clone the GitHub repository.</li>
<li>Install Ambient with <code>cargo install --path app ambient</code>.</li>
<li>Run the examples in the <code>guest/rust/example</code> directory: <code>ambient run guest/rust/examples/basics/primitives</code></li>
</ol>
<h2 id="running-examples-from-main-as-a-developer"><a class="header" href="#running-examples-from-main-as-a-developer">Running examples from main as a developer</a></h2>
<p>If you are a developer actively working on Ambient, you can run the examples from the <code>guest/rust/examples</code> directory directly, without having to install Ambient.</p>
<ol>
<li>Clone the GitHub repository.</li>
<li>Run the examples in the <code>guest/rust/example</code> directory: <code>cargo run --release -- guest/rust/examples/basics/primitives</code></li>
</ol>
<p>To help with this, the Ambient repository has a tool called <a href="user/../community/contributing.html#campfire">Campfire</a>.
It offers a convenient way to run examples:</p>
<pre><code class="language-sh">cargo cf run primitives
</code></pre>
<p>The name is based on the end of the path, so additional context can be provided if necessary:</p>
<pre><code class="language-sh">cargo cf run basics/primitives
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api"><a class="header" href="#api">API</a></h1>
<h2 id="reference-documentation"><a class="header" href="#reference-documentation">Reference documentation</a></h2>
<p>The full API reference for Ambient can be found on <a href="https://docs.rs/ambient_api">docs.rs</a>.</p>
<p>Note that the published API may not be up to date with the latest Git commit of the runtime - if you are using bleeding-edge features, you will need to document the API yourself using <code>cargo doc -p ambient_api</code> in the <code>guest/rust</code> folder.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<h2 id="running-with-the-debugger"><a class="header" href="#running-with-the-debugger">Running with the debugger</a></h2>
<p>When the client is run with the <code>AMBIENT_DEBUGGER</code> environment variable, or with the <code>--debugger</code> flag, the game is surrounded with a debugger:</p>
<pre><code class="language-sh">AMBIENT_DEBUGGER=1 ambient run examples/minigolf
# or `$env:AMBIENT_DEBUGGER=1` on Windows/PowerShell
# or `ambient run --debugger examples/minigolf`
</code></pre>
<p><img src="user/debugger.png" alt="Debugger surrounding the game with AMBIENT_DEBUGGER" /></p>
<p>These can be used to inspect the state of the client and server ECSes, as well as the renderer. When one of these buttons are pressed, a YAML file will be created with the corresponding state, and its path will be written to <code>stdout</code>:</p>
<pre><code class="language-log">[2023-02-23T17:47:36Z INFO  ambient_debugger] Wrote &quot;Ambient/tmp/server_hierarchy.yml&quot;
</code></pre>
<p>Here is some sample output for the server ECS:</p>
<pre><code class="language-yaml">- &quot;id=RsE148MNkdB24bFWQrfeMA loc=48:0&quot;:
    &quot;core::app::main_scene&quot;: ()
    &quot;core::ecs::children&quot;: &quot;[EntityId(koK-dbeCZDrcHzsT7QELUw, 110383077981027712353063371358575952530)]&quot;
    &quot;core::transform::translation&quot;: &quot;Vec3(-5.0, -0.0019752309, 2.8536541)&quot;
    &quot;core::transform::scale&quot;: &quot;Vec3(1.0, 1.0, 1.0)&quot;
    &quot;core::transform::rotation&quot;: &quot;Quat(0.0, 0.0, 0.0, 1.0)&quot;
    &quot;core::transform::local_to_world&quot;: &quot;Mat4 { x_axis: Vec4(1.0, 0.0, 0.0, 0.0), y_axis: Vec4(0.0, 1.0, 0.0, 0.0), z_axis: Vec4(0.0, 0.0, 1.0, 0.0), w_axis: Vec4(-5.0, -0.001970334, 2.8387475, 1.0) }&quot;
    &quot;core::transform::spherical_billboard&quot;: ()
  children:
    - &quot;id=koK-dbeCZDrcHzsT7QELUw loc=46:0&quot;:
        &quot;core::app::main_scene&quot;: ()
        &quot;core::transform::local_to_world&quot;: &quot;Mat4 { x_axis: Vec4(0.02, 0.0, 0.0, 0.0), y_axis: Vec4(0.0, -0.02, 1.7484555e-9, 0.0), z_axis: Vec4(0.0, -1.7484555e-9, -0.02, 0.0), w_axis: Vec4(-5.0, -0.001970334, 2.8387475, 1.0) }&quot;
        &quot;core::transform::local_to_parent&quot;: &quot;Mat4 { x_axis: Vec4(0.02, 0.0, 0.0, 0.0), y_axis: Vec4(0.0, -0.02, 1.7484555e-9, 0.0), z_axis: Vec4(0.0, -1.7484555e-9, -0.02, 0.0), w_axis: Vec4(0.0, 0.0, 0.0, 1.0) }&quot;
        &quot;core::transform::mesh_to_local&quot;: &quot;Mat4 { x_axis: Vec4(1.0, 0.0, 0.0, 0.0), y_axis: Vec4(0.0, 1.0, 0.0, 0.0), z_axis: Vec4(0.0, 0.0, 1.0, 0.0), w_axis: Vec4(0.0, 0.0, 0.0, 1.0) }&quot;
        &quot;core::transform::mesh_to_world&quot;: &quot;Mat4 { x_axis: Vec4(0.02, 0.0, 0.0, 0.0), y_axis: Vec4(0.0, -0.02, 1.7484555e-9, 0.0), z_axis: Vec4(0.0, -1.7484555e-9, -0.02, 0.0), w_axis: Vec4(-5.0, -0.001970334, 2.8387475, 1.0) }&quot;
        &quot;core::rendering::color&quot;: &quot;Vec4(1.0, 0.3, 0.3, 1.0)&quot;
        &quot;core::ui::text&quot;: '&quot;user_470i61dDp7FKjGFQetZ53O&quot;'
        &quot;core::ui::font_size&quot;: &quot;36.0&quot;
        &quot;core::player::user_id&quot;: &quot;...&quot;
      children: []
</code></pre>
<h2 id="increasing-log-output"><a class="header" href="#increasing-log-output">Increasing log output</a></h2>
<p>You can also increase the logging output from specific internal modules using the <code>RUST_LOG</code> environment variable,
which accepts <code>module=log_level</code> pairs that are comma-sepparated. Here are some general tips:</p>
<ul>
<li>To debug <strong>your asset pipeline</strong>, set <code>RUST_LOG=ambient_build=info</code>. For even more logs, you can set <code>RUST_LOG=ambient_build=info,ambient_model_import=info</code>.</li>
<li>To debug <strong>rendering</strong>, set <code>RUST_LOG=ambient_renderer=info</code>.</li>
<li>To debug <strong>networking</strong>, set <code>RUST_LOG=ambient_network=info</code>.</li>
<li>To debug <strong>physics</strong>, set <code>RUST_LOG=ambient_physics=info</code>.</li>
<li>To debug everything, set <code>RUST_LOG=info</code>. To get even more logs set <code>RUST_LOG=debug</code>.</li>
</ul>
<h2 id="physics"><a class="header" href="#physics">Physics</a></h2>
<p>Ambient uses PhysX 4.1 from Nvidia for physics simulation. As a result, the entire physics scene can be visualized using the <a href="https://developer.nvidia.com/physx-visual-debugger">PhysX Visual Debugger (PVD)</a>.</p>
<p>By default, physics debugging is on. To debug your scene, install and start PVD, then start an Ambient project. Your project's scene should automatically be visible within PVD. For more details on how to use PVD, see the <a href="https://gameworksdocs.nvidia.com/PhysX/4.1/documentation/physxguide/Manual/VisualDebugger.html">guide</a>.</p>
<h2 id="assets"><a class="header" href="#assets">Assets</a></h2>
<p>When assets are compiled by the assets pipeline, the resulting artifacts will be output to the <code>build</code> directory in your project. These can be examined to determine whether or not your source was accurately compiled by the asset pipeline.</p>
<p>Additionally, if there are fatal errors or warnings, the asset pipeline will report them during the compilation process.</p>
<h2 id="networking"><a class="header" href="#networking">Networking</a></h2>
<h3 id="debugging-which-components-are-sent-over-the-network"><a class="header" href="#debugging-which-components-are-sent-over-the-network">Debugging which components are sent over the network</a></h3>
<p>Use the environment flag <code>AMBIENT_DEBUG_ENTITY_STREAM</code> to debug entities and components sent over the network to the client. <code>AMBIENT_DEBUG_ENTITY_STREAM=FULL</code> will output everything, <code>AMBIENT_DEBUG_ENTITY_STREAM=true</code> (or anything else) will output a summary.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="profiling"><a class="header" href="#profiling">Profiling</a></h1>
<p>Ambient supports profiling through <a href="https://github.com/EmbarkStudios/puffin">puffin</a>. To use it, follow these steps:</p>
<ol>
<li>
<p>Build Ambient with profiling enabled (add the <code>profile</code> feature flag). From the root folder:</p>
<pre><code class="language-sh">cargo install --path app --features profile
</code></pre>
</li>
<li>
<p>Install <a href="https://crates.io/crates/puffin_viewer">puffin_viewer</a>:</p>
<pre><code class="language-sh">cargo install puffin_viewer
</code></pre>
</li>
<li>
<p>Start Ambient:</p>
<pre><code class="language-sh">ambient run guest/examples/basics/primitives
</code></pre>
</li>
<li>
<p>Start <code>puffin_viewer</code>:</p>
<pre><code class="language-sh">puffin_viewer
</code></pre>
</li>
</ol>
<p>You should now see real-time performance metrics for Ambient.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-content-for-your-game"><a class="header" href="#getting-content-for-your-game">Getting content for your game</a></h1>
<p>Content, including assets, is a key part of any game. For a polished game, you will likely want to
build your own content. However, for prototyping, or for a game jam, you may want to use existing
content.</p>
<p>This page lists some sources of content that you can use in your game.</p>
<p>For details on how to import the content, see <a href="reference/./asset_pipeline.html">asset pipeline</a>.</p>
<h2 id="characters-and-animations"><a class="header" href="#characters-and-animations">Characters and animations</a></h2>
<ul>
<li><a href="https://www.mixamo.com">Mixamo</a>: Free characters and animations.</li>
</ul>
<h2 id="models"><a class="header" href="#models">Models</a></h2>
<ul>
<li><a href="https://assetstore.unity.com/">Unity asset store</a>: Lots of content. The Ambient asset pipeline supports importing Unity models. However, ensure that the license allows you to use the content in your game.</li>
<li><a href="https://quixel.com/">Quixel</a>: Realistic scanned models. The asset pipeline supports importing Quixel models. However, ensure that the license allows you to use the content in your game.</li>
<li><a href="https://sketchfab.com/">Sketchfab</a>: Many models.</li>
</ul>
<h2 id="materials"><a class="header" href="#materials">Materials</a></h2>
<ul>
<li><a href="https://ambientcg.com/">https://ambientcg.com/</a>: Many materials.</li>
</ul>
<h2 id="collections"><a class="header" href="#collections">Collections</a></h2>
<ul>
<li><a href="https://github.com/madjin/awesome-cc0">awesome-cc0</a>: A list of Creative Commons 0 (CC0) licensed assets. These assets can be used for any purpose, including commercially.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="runtime"><a class="header" href="#runtime">Runtime</a></h1>
<h2 id="coordinate-system"><a class="header" href="#coordinate-system">Coordinate system</a></h2>
<p>By default, Ambient uses a right-handed coordinate system for NDC with <code>z</code> from 1 to 0 (i.e. reverse-z with the near plane at <code>z=1</code>, and the far plane at <code>z=0</code>).</p>
<p>For world coordinates, it uses a left-handed system. We consider <code>x</code> to be right, <code>y</code> to be back, and <code>z</code> to be up (same as Unreal). This means that the default camera without any transformation is lying on its stomach and facing downwards.</p>
<pre><code>NDC:
   y
   |
   |
   0 ---&gt; x
 /
z (coming out of the screen)

World:
  z (up)
  |
  0 --- x (right)
 /
y
</code></pre>
<p>WebGPU uses positive-<code>y</code> as up in its NDC, and <code>z</code> from 0 to 1 (https://gpuweb.github.io/gpuweb/#coordinate-systems) - that is, it is left-handed.</p>
<p>Freya Holmér has produced an overview of which programs use which coordinate systems, which can be found <a href="https://twitter.com/freyaholmer/status/1325556229410861056">here</a>.</p>
<p>For more information on our use of reverse-z, consult the following links:</p>
<ul>
<li>https://developer.nvidia.com/content/depth-precision-visualized</li>
<li>https://www.danielecarbone.com/reverse-depth-buffer-in-opengl/</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ember"><a class="header" href="#ember">Ember</a></h1>
<p>All Ambient embers must have an <code>ambient.toml</code> manifest that describes their functionality. This format is in flux, but is inspired by Rust's <code>Cargo.toml</code>.</p>
<p>At present, dependencies are <em>not</em> supported, but this will change in future.</p>
<h2 id="webassembly"><a class="header" href="#webassembly">WebAssembly</a></h2>
<p>All <code>.wasm</code> components in the <code>build/{client, server}</code> directory will be loaded for the given target, regardless of provenance. The <code>.wasm</code> filenames must be snake-case ASCII identifiers, like the <code>id</code> in the manifest.</p>
<p>This means any <code>.wasm</code> that implements the Ambient <a href="https://github.com/AmbientRun/Ambient/tree/main/crates/wasm/wit">WIT interface</a> and targets WASI snapshot 2 (or uses an adapter that targets WASI snapshot 2) should run within Ambient.</p>
<p>As a convenience for Rust users, Ambient will automatically build a <code>Cargo.toml</code> at the root of your ember, if present, as <code>wasm32-wasi</code> for the features specified in <code>build.rust.feature-multibuild</code> in <code>ambient.toml</code> (defaults to <code>client</code> and <code>server</code>).</p>
<p>The default new ember template will create <code>client.rs</code> and <code>server.rs</code> files, with a <code>Cargo.toml</code> preconfigured with targets for both. The resulting WASM bytecode files are then converted to components and placed in <code>build/{client, server}</code>.</p>
<p>The process it takes is equivalent to these commands:</p>
<pre><code class="language-sh">cd your_ember
cargo build --target wasm32-wasi --features client
wasm-tools component new target/wasm32-wasi/debug/your_ember_client.wasm -o build/client/your_ember.wasm --adapt wasi_snapshot_preview1.wasm
cargo build --target wasm32-wasi --features server
wasm-tools component new target/wasm32-wasi/debug/your_ember_server.wasm -o build/server/your_ember.wasm --adapt wasi_snapshot_preview1.wasm
</code></pre>
<p>using <a href="https://github.com/bytecodealliance/wasm-tools">wasm-tools</a> and a bundled version of the <a href="https://github.com/bytecodealliance/preview2-prototyping">preview2-prototyping WASI adapter</a>.</p>
<h2 id="reference"><a class="header" href="#reference">Reference</a></h2>
<p><code>Identifier</code>s are snake-case ASCII identifiers (as a string), and <code>IdentifierPath</code>s are a double-colon-separated list of <code>Identifier</code>s. For example, <code>my_ember</code> is an <code>Identifier</code>, and <code>my_ember::my_component</code> is an <code>IdentifierPath</code>.</p>
<h3 id="ember--ember"><a class="header" href="#ember--ember">Ember / <code>[ember]</code></a></h3>
<p>The ember section contains metadata about the ember itself, such as its name and version.</p>
<table><thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>id</code></td><td><code>Identifier</code></td><td><em>Required</em>. The ember's snake-cased ID.</td></tr>
<tr><td><code>name</code></td><td><code>String</code></td><td><em>Required</em>. A human-readable name for the ember.</td></tr>
<tr><td><code>description</code></td><td><code>String</code></td><td><em>Required</em>. A human-readable description of the ember.</td></tr>
<tr><td><code>version</code></td><td><code>String</code></td><td><em>Required</em>. The ember's version, in <code>(major, minor, patch)</code> format. Semantically versioned.</td></tr>
</tbody></table>
<h3 id="build--build"><a class="header" href="#build--build">Build / <code>[build]</code></a></h3>
<p>The build section contains settings related to building the ember.</p>
<h4 id="rust-settings--buildrust"><a class="header" href="#rust-settings--buildrust">Rust Settings / <code>[build.rust]</code></a></h4>
<table><thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>feature-multibuild</code></td><td><code>String[]</code></td><td><em>Optional</em>. An array of strings defining the features to be used when building the ember. This is used to build the same code for both client and server.<br /><br />Client and server are built by default (e.g. <code>[&quot;client&quot;, &quot;server&quot;]</code>); this is exposed so that you can disable building one side entirely if required.</td></tr>
</tbody></table>
<h3 id="components--components"><a class="header" href="#components--components">Components / <code>[components]</code></a></h3>
<p>The components section contains custom components defined by the ember. Components are used to store data on entities.</p>
<p>This is a TOML table, where the keys are the component IDs (<code>IdentifierPath</code>), and the values are the component definitions.</p>
<table><thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>type</code></td><td><code>ComponentType</code></td><td><em>Required</em>. The type of the component.</td></tr>
<tr><td><code>name</code></td><td><code>String</code></td><td><em>Required</em>. A human-readable name for the component.</td></tr>
<tr><td><code>description</code></td><td><code>String</code></td><td><em>Required</em>. A human-readable description of the component.</td></tr>
<tr><td><code>attributes</code></td><td><code>ComponentAttribute[]</code></td><td><em>Optional</em>. An array of attributes for the component.</td></tr>
</tbody></table>
<p>A <code>ComponentType</code> is either:</p>
<ul>
<li>
<p>a string that can be one of the following primitive types:</p>
<ul>
<li><code>Bool</code>: a boolean value, true or false</li>
<li><code>Empty</code>: a component that has no value; most often used for tagging an entity</li>
<li><code>EntityId</code>: an entity ID</li>
<li><code>F32</code>: a 32-bit floating point value</li>
<li><code>F64</code>: a 64-bit floating point value</li>
<li><code>Mat4</code>: a 4x4 32-bit floating point matrix</li>
<li><code>Quat</code>: a 32-bit floating point quaternion</li>
<li><code>String</code>: a UTF-8 string</li>
<li><code>U8</code>: an 8-bit unsigned integer value</li>
<li><code>U16</code>: an 16-bit unsigned integer value</li>
<li><code>U32</code>: a 32-bit unsigned integer value</li>
<li><code>U64</code>: a 64-bit unsigned integer value</li>
<li><code>I8</code>: an 8-bit signed integer value</li>
<li><code>I16</code>: an 16-bit signed integer value</li>
<li><code>I32</code>: a 32-bit signed integer value</li>
<li><code>I64</code>: a 64-bit signed integer value</li>
<li><code>Uvec2</code>: a 2-element 32-bit unsigned integer vector</li>
<li><code>Uvec3</code>: a 3-element 32-bit unsigned integer vector</li>
<li><code>Uvec4</code>: a 4-element 32-bit unsigned integer vector</li>
<li><code>Ivec2</code>: a 2-element 32-bit signed integer vector</li>
<li><code>Ivec3</code>: a 3-element 32-bit signed integer vector</li>
<li><code>Ivec4</code>: a 4-element 32-bit signed integer vector</li>
<li><code>Vec2</code>: a 2-element 32-bit floating point vector</li>
<li><code>Vec3</code>: a 3-element 32-bit floating point vector</li>
<li><code>Vec4</code>: a 4-element 32-bit floating point vector</li>
<li><code>Duration</code>: A time span. Often used as a timestamp, in which case it designates the duration since Jan 1, 1970.</li>
</ul>
</li>
<li>
<p>a contained type of the form <code>{ type = &quot;Vec&quot;, element_type = ComponentType }</code> or <code>{ type = &quot;Option&quot;, element_type = ComponentType }</code></p>
<ul>
<li>Note that <code>Vec</code> and <code>Option</code> are the only supported container types, and <code>element_type</code> must be a primitive <code>ComponentType</code> (that is, you cannot have nested contained types).</li>
</ul>
</li>
</ul>
<p>A <code>ComponentAttribute</code> is a string that can be one of the following:</p>
<ul>
<li><code>Debuggable</code>: this component can have its debug value printed, especially in ECS dumps</li>
<li><code>Networked</code>: this component is networked</li>
<li><code>Resource</code>: this component will only ever be used as a resource; will error if attached to an entity</li>
<li><code>MaybeResource</code>: this component can be used as a resource or as a component; necessary if treating this component as a resource</li>
<li><code>Store</code>: this component's value should be persisted when the world is saved</li>
</ul>
<h3 id="concepts--concepts"><a class="header" href="#concepts--concepts">Concepts / <code>[concepts]</code></a></h3>
<p>The concepts section contains custom concepts defined by the ember. Concepts are used to define a set of components that can be attached to an entity.</p>
<p>This is a TOML table, where the keys are the concept IDs (<code>Identifier</code>), and the values are the concept definitions.</p>
<table><thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td><code>String</code></td><td><em>Required</em>. A human-readable name for the concept.</td></tr>
<tr><td><code>description</code></td><td><code>String</code></td><td><em>Required</em>. A human-readable description of the concept.</td></tr>
<tr><td><code>extends</code></td><td><code>String[]</code></td><td><em>Optional</em>. An array of concepts to extend. Must be defined in this ember manifest.</td></tr>
<tr><td><code>components</code></td><td><code>Map&lt;IdentifierPath, any&gt;</code></td><td><em>Required</em>. An object containing the components and their default values. Must be components defined in this ember manifest.</td></tr>
</tbody></table>
<p>The <code>components</code> is an object where the keys are <code>IdentifierPath</code>s of components defined in the ember manifest (at this time, it must be in the same manifest), and the values are the default values for those components in the concept.</p>
<h3 id="messages--messages"><a class="header" href="#messages--messages">Messages / <code>[messages]</code></a></h3>
<p>The messages section contains custom messages defined by the ember. Messages are used to communicate between client and server.</p>
<p>For an example of how to use messages, see the <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/basics/messaging">messaging example</a>.</p>
<p>This is a TOML table, where the keys are the message IDs (<code>Identifier</code>), and the values are the message definitions.</p>
<table><thead><tr><th>Property</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>name</code></td><td><code>String</code></td><td><em>Required</em>. A human-readable name for the message.</td></tr>
<tr><td><code>description</code></td><td><code>String</code></td><td><em>Required</em>. A human-readable description of the message.</td></tr>
<tr><td><code>fields</code></td><td><code>Map&lt;Identifier, ComponentType&gt;</code></td><td><em>Required</em>. An object containing the fields and their types. Must be one of the types supported for components.</td></tr>
</tbody></table>
<h2 id="sample-ambienttoml"><a class="header" href="#sample-ambienttoml">Sample <code>ambient.toml</code></a></h2>
<p>A sample <code>ambient.toml</code> is shown below:</p>
<!-- TODO: autogenerate with generate-docs -->
<pre><code class="language-toml">#
# The ember section describes all ember metadata.
#
[ember]
# This must be a snake-cased name.
id = &quot;my_cool_ember&quot;
# This name is human-readable and can contain anything.
name = &quot;My Cool Ember&quot;
# This description is human-readable and can contain anything.
description = &quot;A sample ember that's the coolest thing ever.&quot;
# Embers are expected to use (major, minor, patch) semantic versioning.
# Other formats are not accepted. This requirement may be relaxed later.
version = &quot;0.0.1&quot;

#
# Build settings.
#
[build]
# Rust-specific settings.
[build.rust]
# `cargo build` will be run with each of these features to produce a separate WASM binary,
# which is then componentized and copied into a folder of the corresponding name in `build/`.
# This is used to build the same code for both client and server.
# Client and server are built by default; this is exposed so that you can disable building one
# side entirely if required.
# You will normally not need to touch this.
feature-multibuild = [&quot;client&quot;, &quot;server&quot;]

#
# Custom components defined by this ember.
# Components are used to store data on entities.
#
[components]
# Inline tables can be used.
cool_component = { type = &quot;I32&quot;, name = &quot;Cool Component&quot;, description = &quot;A cool component&quot;, attributes = [&quot;Debuggable&quot;] }
# Explicit tables can also be used.
[components.cool_component2]
# At time of writing, supported component types are:
#   Empty, Bool, String,
#   EntityId,
#   F32, F64, Mat4, Quat,
#   U8, U16, U32, U64,
#   I8, I16, I32, I64,
#   Vec2, Vec3, Vec4,
#   Uvec2, Uvec3, Uvec4,
#   Ivec2, Ivec3, Ivec4
# or
#   { type = &quot;Vec&quot;, element_type = &quot;TypeFromAbove&quot; }
#   { type = &quot;Option&quot;, element_type = &quot;TypeFromAbove&quot; }
# You cannot nest container types.
type = &quot;I32&quot;
name = &quot;Cool Component 2&quot;
description = &quot;A cool component 2&quot;
# At time of writing, supported attributes are:
#   Debuggable: this component can have its debug value printed, especially in ECS dumps
#   Networked: this component is networked
#   Resource: this component will only ever be used as a resource; will error if attached to an entity
#   MaybeResource: this component can be used as a resource or as a component; necessary if treating this component as a resource
#   Store: this component's value should be persisted when the world is saved
attributes = [&quot;Debuggable&quot;]
# Namespaces are also supported:
&quot;cool::component&quot; = { type = &quot;I32&quot;, name = &quot;Cool Component&quot;, description = &quot;A cool component&quot;, attributes = [&quot;Debuggable&quot;] }

#
# Custom concepts defined by this ember.
# Concepts are used to define a set of components that can be attached to an entity.
#
[concepts]
[concepts.concept1]
# The name of the concept.
name = &quot;Concept 1&quot;
# The description of the concept.
description = &quot;The best&quot;
[concepts.transformable.components]
# Each component needs to be specified with a default value.
# At time of writing, you can only use components defined in this ember manifest.
cool_component = 0

# A concept that extends `concept1` and has both `cool_component` and `cool_component2`.
[concepts.concept2]
name = &quot;Concept 2&quot;
description = &quot;The successor&quot;
# At time of writing, all concepts being extended must be defined in this ember manifest.
extends = [&quot;concept1&quot;]
[concepts.concept2.components]
cool_component2 = 1

#
# Custom messages defined by this ember.
# Messages are used to communicate between client and server.
#
[messages]
[messages.input]
# The name of the message.
name = &quot;Input&quot;
# The description of the message.
description = &quot;Describes the input state of the player.&quot;
[messages.input.fields]
# Each field in the message must have a type, name and description. The supported types are the same as for components.
direction = { type = &quot;Vec2&quot;, name = &quot;Direction&quot;, description = &quot;The movement direction of the player.&quot; }
mouse_delta_x = { type = &quot;F32&quot;, name = &quot;Mouse delta X&quot;, description = &quot;The mouse delta X.&quot; }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entity-component-system-ecs"><a class="header" href="#entity-component-system-ecs">Entity Component System (ECS)</a></h1>
<p>An entity component system (ECS) is an architectural pattern that is used in game development to organize the logic of a game. It is a data-oriented approach to programming, which means that it focuses on the data that is being processed, rather than the logic that is processing it.</p>
<p>The ECS pattern is based on three concepts: <em>entities</em>, <em>components</em>, and <em>systems</em>. Entities are the objects that exist in the game world. Components are the data that describe the entities. Systems are the logic that processes the components.</p>
<p>Conceptually, the ECS can be considered to be a database, where the entities are the rows, the components are the columns, and the systems are the queries. The ECS is designed to be fast and efficient, and is used in many modern game engines.</p>
<p>In addition to the three core concepts, Ambient also supports <em>concepts</em>, which are a way of defining a collection of components that correspond to some concept in the game world. For example, a <code>Player</code> concept might be defined as a collection of components that describe the player's health, inventory, and position.</p>
<h2 id="entities"><a class="header" href="#entities">Entities</a></h2>
<p>Entities are the objects that exist in the game world. They consist of a unique identifier (an <code>EntityId</code>, which is 128 bits) and a set of components. Entities are created and destroyed dynamically during runtime.</p>
<h2 id="components"><a class="header" href="#components">Components</a></h2>
<p>Components are pieces of data that can be attached to entities. They store information like health, position, velocity, and more. Components are defined in the ember manifest, and are attached to entities at runtime.</p>
<p>They are defined in the manifest (and not your codebase) so that other embers that depend on your ember can use them when interacting with the ECS. Additionally, this means that component definitions are not tied to a specific language, and can be used in any language that supports the runtime.</p>
<p>For more detail on what components can be, see the <a href="reference/ember.html#components--components">ember manifest reference</a>. Note that component types cannot be nested - you cannot have a component that is a <code>Vec</code> of <code>Vec</code>s.</p>
<h3 id="attributes"><a class="header" href="#attributes">Attributes</a></h3>
<p>Components can have attributes that modify their behavior. These attributes are defined in the ember manifest, and are used by the runtime to determine how to handle the component.</p>
<h4 id="debuggable"><a class="header" href="#debuggable"><code>Debuggable</code></a></h4>
<p>This component can have its debug value printed. This is most often used for ECS dumps, but can also be used for debugging purposes.</p>
<h4 id="networked"><a class="header" href="#networked"><code>Networked</code></a></h4>
<p>This component is networked to the client. This means that the component's value will be sent to the client when the component is created, and whenever the component's value changes.</p>
<p>Note that a component that is <code>Networked</code> on the client will <em>not</em> be networked to the server. Ambient's ECS networking is strictly server to client; to send data from the client to the server, you must use <a href="reference/ember.html#messages--messages">messages</a>.</p>
<h4 id="resource"><a class="header" href="#resource"><code>Resource</code></a></h4>
<p>This component will only ever be attached to the <code>entity::resources()</code> entity, which is always present in the world. This is useful for storing global state that is not tied to a specific entity.</p>
<p>This component will error when attached to any other entity. Note that the resources entity is not networked; if you want networked global state, consider using <code>entity::synchronized_resources()</code>.</p>
<h4 id="mayberesource"><a class="header" href="#mayberesource"><code>MaybeResource</code></a></h4>
<p>This component can be used as either a resource or as a component. This is useful for components that are traditionally attached to entities, but are sometimes attached to the resource entity.</p>
<p>This is most commonly used for components that are used in the resources of a prefab to provide metadata about the prefab. It is unlikely you will need to interact with this directly as a user.</p>
<h4 id="store"><a class="header" href="#store"><code>Store</code></a></h4>
<p>This component's value will be stored in the world file. This is useful for components that store persistent state, like the player's inventory.</p>
<p>At present, Ambient does not support persistency. This functionality will be added in the future.</p>
<h2 id="systems"><a class="header" href="#systems">Systems</a></h2>
<p>Systems are the logic that processes the components. Ambient guest code cannot directly define systems; instead, they rely on queries that run every frame. These function identically to systems for now, but systems may be formally introduced in the future to allow for more advanced functionality, including automatic parallelism of the ECS.</p>
<p>Queries are powerful, and can be used to query for entities that have a specific component, or a specific set of components. At present, they are entirely structural, so they cannot be used to query for entities that have a specific value for a component.</p>
<p>There are three types of queries in Ambient at present: general queries, (de)spawn queries, and change queries.</p>
<p>General queries are the most common type of query. They are used to query for entities that have a specific set of components:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>query((player(), player_camera_ref(), translation(), rotation())).each_frame(move |players| {
    for (_, (_, camera_id, pos, rot)) in players {
        let forward = rot * Vec3::X;
        entity::set_component(camera_id, lookat_target(), pos);
        entity::set_component(camera_id, translation(), pos - forward * 4. + Vec3::Z * 2.);
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>Spawn queries are used to query for when specific components are added to entities (including the entire entity being spawned). They are useful for spawning entities when a player joins the game, for example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>spawn_query(player()).bind(move |players| {
    // For each player joining, spawn a random colored box somewhere
    for _ in players {
        Entity::new()
            .with_merge(make_transformable())
            .with_default(cube())
            .with(translation(), rand::random())
            .with(color(), rand::random::&lt;Vec3&gt;().extend(1.0))
            .spawn();
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>Despawn queries are similar to spawn queries, but track the removal of components from entities (including the entire entity being despawned). They are useful for cleaning up entities when a player leaves the game, for example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>despawn_query(user_id()).requires(player()).bind(move |players| {
    for (_, user_id) in players {
        println!(&quot;Player {user_id} left&quot;);
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>Finally, change queries are activated when one of the components they track change. Note that the components that are returned by the query are separate from the components that are tracked; this allows you to get more information about the entity than just the components that changed.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>change_query((user_id(), health())).track_change(health()).requires(player()).bind(move |players| {
    for (_, (user_id, health)) in players {
        println!(&quot;Player {user_id} now has {health} health&quot;);
    }
});
<span class="boring">}
</span></code></pre></pre>
<p>In addition to specifying components in the query, you can also specify components that must be needed using <code>.requires</code> or components that must not be present using <code>.excludes</code>. These are useful for filtering out entities that should not be processed by the query.</p>
<h2 id="concepts"><a class="header" href="#concepts">Concepts</a></h2>
<p>Concepts are defined in the ember manifest, and are used to define a collection of components that correspond to some concept in the game world. For example, a <code>Player</code> concept might be defined as a collection of components that describe the player's health, inventory, and position.</p>
<p>Concepts have an ID (specified as the name of their TOML table), a name, a description, and a list of components with defaults. Additionally, they can extend other concepts, which will cause them to inherit the components and defaults of the concept they extend.</p>
<p>For illustration, here are two concepts that are defined as part of Ambient's default manifest:</p>
<pre><code class="language-toml">[concepts.transformable]
name = &quot;Transformable&quot;
description = &quot;Can be translated, rotated and scaled.&quot;

[concepts.transformable.components]
&quot;core::transform::translation&quot; = [0.0, 0.0, 0.0]
&quot;core::transform::scale&quot; = [1.0, 1.0, 1.0]
&quot;core::transform::rotation&quot; = [0.0, 0.0, 0.0, 1.0]

[concepts.camera]
name = &quot;Camera&quot;
description = &quot;Base components for a camera. You will need other components to make a fully-functioning camera.&quot;
extends = [&quot;transformable&quot;]

[concepts.camera.components]
&quot;core::app::name&quot; = &quot;Camera&quot;
&quot;core::camera::near&quot; = 0.1
&quot;core::camera::projection&quot; = [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]
&quot;core::camera::projection_view&quot; = [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]
&quot;core::camera::active_camera&quot; = 0.0
&quot;core::transform::local_to_world&quot; = [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]
&quot;core::transform::inv_local_to_world&quot; = [1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0]
</code></pre>
<p>In this example, the &quot;camera&quot; concept contains all of the components from a transformable, as well as components of its own. This means that any entity that has the &quot;camera&quot; concept will also have the components from the &quot;transformable&quot; concept.</p>
<p>Concepts are exposed to your Rust code in three ways, using <code>camera</code> as an example:</p>
<ul>
<li><code>camera()</code>: returns a tuple of the components that are part of the <code>camera</code> concept. This can be used within queries to query for entities that have the <code>camera</code> concept.</li>
<li><code>make_camera()</code>: makes a <code>Entity</code> with the components of the <code>camera</code> concept, which can then be spawned.</li>
<li><code>is_camera(id)</code>: returns true if the entity with the given ID contains all of the components of the <code>camera</code> concept.</li>
</ul>
<h2 id="what-is-the-components-macro-in-host-code"><a class="header" href="#what-is-the-components-macro-in-host-code">What is the <code>components!</code> macro in host code?</a></h2>
<p>This section is not relevant to those developing games using Ambient, and is only relevant to those who are developing Ambient itself.</p>
<p>At the root of the repository, there is an <code>ambient.toml</code> that defines all of the guest-visible components for Ambient. This is what runtime developers will typically add to when they want to add new components to Ambient.</p>
<p>However, there are some components that are not visible to guest code, but are still defined in host code. These components are defined using the <code>components!</code> macro. It is used like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>components!(&quot;app&quot;, {
    @[MakeDefault[default_title], Debuggable, MaybeResource]
    window_title: String,
    fps_stats: FpsSample,
});
<span class="boring">}
</span></code></pre></pre>
<p>Unlike <code>ambient.toml</code>, components can be of any type that meet a set of requirements. Additionally, the components defined here will not be visible to guest code. The attributes available are a superset of those available to <code>ambient.toml</code>.</p>
<p>These component definitions are primarily useful for internal data that needs to be attached to entities, but should not be or cannot be visible to guest code. For example, the <code>FpsSample</code> struct in the example above is a complex type and cannot be stored in a component in guest code, but it can be stored in a component in host code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="models-1"><a class="header" href="#models-1">Models</a></h1>
<p>Models are 3D objects (characters, vehicles, buildings, etc) that can be rendered to the screen. They can be loaded from files, or procedurally generated.</p>
<h2 id="importing-a-model"><a class="header" href="#importing-a-model">Importing a model</a></h2>
<p>To use a model in Ambient, place it in the <code>assets</code> folder, and then create a <code>assets/pipeline.toml</code> file:</p>
<pre><code class="language-toml">[[pipelines]]
type = &quot;Models&quot;
</code></pre>
<p>See <a href="reference/./asset_pipeline.html">asset pipeline</a> for more details.</p>
<h2 id="spawning-a-model"><a class="header" href="#spawning-a-model">Spawning a model</a></h2>
<p>The model can then be spawned using <code>prefab_from_url</code>, assuming that <code>output_prefabs</code> is enabled in your <code>assets/pipeline.toml</code> file (it is enabled by default).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Entity::new()
    .with_merge(make_transformable())
    .with(prefab_from_url(), asset::url(&quot;assets/MyModel.fbx&quot;).unwrap())
    .spawn();
<span class="boring">}
</span></code></pre></pre>
<p>The prefabs generated by the pipeline include the visual model and physics colliders.
If the code above lives in your <code>server.rs</code> file, it will create the physics colliders on the server.
The model, including any skeletons it may have, will always be loaded and spawned on the clientside, regardless of if the above code lives in <code>server.rs</code> or <code>client.rs</code>. It is not guaranteed that the model will be loaded on the server, so you should not rely on it being there.</p>
<p>You can also use <code>model_from_url</code> to load a model without the physics colliders.</p>
<h2 id="animating-a-model"><a class="header" href="#animating-a-model">Animating a model</a></h2>
<p>See <a href="reference/./animations.html">animations</a>.</p>
<h2 id="getting-models-for-your-project"><a class="header" href="#getting-models-for-your-project">Getting models for your project</a></h2>
<p>See <a href="reference/./getting_content.html">getting content</a> for a list of places where you can get models.</p>
<h2 id="manipulating-bones"><a class="header" href="#manipulating-bones">Manipulating bones</a></h2>
<p>You can get individual bones of a loaded model using the <code>animation::get_bone_by_bind_id</code> function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let unit_id = Entity::new()
    .with_merge(make_transformable())
    .with(prefab_from_url(), asset::url(&quot;assets/MyModel.fbx&quot;).unwrap())
    .spawn();
let left_foot = animation::get_bone_by_bind_id(unit_id, &amp;BindId::LeftFoot).unwrap();
entity::set_component(left_foot, rotation(), Quat::from_rotation_x(0.3));
<span class="boring">}
</span></code></pre></pre>
<p>This will only work on the client at present, as the skeleton is not loaded on the server.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hierarchies-and-transforms"><a class="header" href="#hierarchies-and-transforms">Hierarchies and transforms</a></h1>
<p>Ambient supports hierarchies of entities using the <code>parent</code> and <code>children</code> components. Both need to be present for a hierarchy to be valid - as an example, the following entities in the ECS</p>
<pre><code class="language-yml">entity a:
  - children: [b, c]
entity b:
  - parent: a
entity c:
  - parent: a
</code></pre>
<p>will produce the hierarchy:</p>
<pre><code>entity a
    entity b
    entity c
</code></pre>
<p>If you are creating hierachies yourself, you need to make sure that both <code>parent</code> and <code>children</code> exists and are correct for the hierarchy to work.</p>
<p>The <code>entity::add_child</code> and <code>entity::remove_child</code> functions can be used to add and remove children from a parent.</p>
<p>When using the <code>model_from_url</code> or <code>prefab_from_url</code> components, the entire model sub-tree will be spawned in, with the root of the sub-tree being added as a child to the entity with the component. Each entity in the sub-tree will be part of the hierarchy using their own <code>parent</code> and <code>children</code> components.</p>
<h2 id="transforms-in-hierarchies"><a class="header" href="#transforms-in-hierarchies">Transforms in hierarchies</a></h2>
<p>Hierarchies are common to use for transforms where a root entity is moved around and all its children should move with it.
To apply transforms to a hierarchy, <code>local_to_parent</code> must be used:</p>
<pre><code class="language-yml">entity a:
  - children: [b]
  - local_to_world: Mat4(..)
entity b:
  - parent: a
  - local_to_parent: Mat4(..)
  - local_to_world: Mat4(..)
</code></pre>
<p>In this case, <code>b.local_to_world</code> will be calculated as <code>a.local_to_world * b.local_to_parent</code>.</p>
<p><code>local_to_world</code> and <code>local_to_parent</code> are the only matrices necessary here. However, it is often more convenient to work with <code>translation</code>, <code>rotation</code> and <code>scale</code> components:</p>
<pre><code class="language-yml">entity a:
  - children: [b]
  - local_to_world: Mat4(..)
  - translation: vec3(5., 2., 9.)
  - rotation: quat(..)
  - scale: vec3(0.5, 0.5, 1.)
entity b:
  - parent: a
  - local_to_parent: Mat4(..)
  - local_to_world: Mat4(..)
  - translation: vec3(-2., 0., 0.)
  - rotation: quat(..)
  - scale: vec3(1., 2., 1.)
</code></pre>
<p>In this case, the <code>local_to_world</code> and <code>local_to_parent</code> will automatically be recalculated from <code>translation</code>, <code>rotation</code> and <code>scale</code> whenever they change; the following computations will happen in this order:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>a.local_to_world = mat4_from(a.scale, a.rotation, a.translation);
b.local_to_parent = mat4_from(b.scale, b.rotation, b.translation);
b.local_to_world = a.local_to_world * b.local_to_parent;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asset-pipeline"><a class="header" href="#asset-pipeline">Asset pipeline</a></h1>
<!-- markdownlint-disable-file MD024 -->
<p>Ambient features an automated asset pipeline that is capable of loading and processing a number of assets and formats.</p>
<p>In a folder with assets, create a file with a name ending in <code>pipeline.toml</code>; examples include <code>pipeline.toml</code> and <code>hello_pipeline.toml</code>. The prefix can be used to disambiguate between different pipelines.</p>
<p>This pipelines will look at, but not necessarily process, all of the files adjacent to it in the folder. By convention,
our examples place their assets in the <code>assets</code> folder, but this is not necessary.</p>
<h2 id="models-2"><a class="header" href="#models-2">Models</a></h2>
<p>The <code>Models</code> pipeline can be used to compile a model, or models, to meshes that can be used by Ambient. Additionally, by
default, prefabs are created for each mesh. These prefabs can have components automatically added to them through the
<code>prefab_components</code> field of the pipeline.</p>
<h3 id="supported-formats"><a class="header" href="#supported-formats">Supported formats</a></h3>
<ul>
<li>FBX: Native support</li>
<li>glTF: Native support</li>
<li>Unity models: Native support</li>
<li>Quixel models: Native support</li>
<li>~30 other formats: This support is provided through the <a href="https://github.com/assimp/assimp">assimp</a> library. It is not
guaranteed to be fully integrated. By default, Ambient is not built with <code>assimp</code> support due to issues with cross-platform builds.</li>
</ul>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<h4 id="basic-models"><a class="header" href="#basic-models">Basic models</a></h4>
<p>The following will load <code>.glb</code> and <code>.fbx</code> files in the folder or any of the sub-folders.</p>
<pre><code class="language-toml">[[pipelines]]
type = &quot;Models&quot;
</code></pre>
<h4 id="different-pipelines-for-different-files"><a class="header" href="#different-pipelines-for-different-files">Different pipelines for different files</a></h4>
<p>You can use the <code>sources</code> attribute to restrict different configurations to different files:</p>
<pre><code class="language-toml">[[pipelines]]
type = &quot;Models&quot;
sources = [ &quot;physical/*.glb&quot; ]

[pipelines.collider]
type = &quot;FromModel&quot;

[[pipelines]]
type = &quot;Models&quot;
sources = [ &quot;ghosts/*.glb&quot; ]
</code></pre>
<p><code>sources</code> accepts a list of glob patterns, so you can target a single file or a pattern to select all files in a
directory (<code>*.glb</code>) or sub-tree (<code>**/test.glb</code>).</p>
<h4 id="a-more-complex-model-example"><a class="header" href="#a-more-complex-model-example">A more complex model example</a></h4>
<p>The following example is the asset pipeline for the <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/basics/asset_loading"><code>asset_loading</code> example</a>. It applies a custom material to
the imported mesh.</p>
<pre><code class="language-toml">[[pipelines]]
type = &quot;Models&quot;
sources = [&quot;*.glb&quot;]

[[pipelines.material_overrides]]

[pipelines.material_overrides.filter]
type = &quot;All&quot;

[pipelines.material_overrides.material]
name = &quot;Planks&quot;
base_color = &quot;./Planks037B_1K-PNG/Planks037B_1K_Color.png&quot;
normalmap = &quot;./Planks037B_1K-PNG/Planks037B_1K_NormalGL.png&quot;
roughness = 0.5
metallic = 0.0

[pipelines.prefab_components]
&quot;ambient_example_asset_loading::is_the_best&quot; = false
</code></pre>
<h3 id="notes"><a class="header" href="#notes">Notes</a></h3>
<ul>
<li>If you are using components in your prefab and are hot-reloading it, the incoming prefab will overwrite any
corresponding components on the current state of the entity. These components should only be used for static data - that
is, <code>max_hitpoints</code> but not <code>current_hitpoints</code>.</li>
</ul>
<h2 id="models-3"><a class="header" href="#models-3">Models</a></h2>
<h3 id="regular"><a class="header" href="#regular">Regular</a></h3>
<p>Consumes model file formats into a hierarchy of entities, materials, and meshes.</p>
<h4 id="supported-formats-1"><a class="header" href="#supported-formats-1">Supported formats:</a></h4>
<ul>
<li><code>glb</code></li>
<li><code>gltf</code></li>
<li><code>fbx</code></li>
<li><code>obj</code></li>
</ul>
<h3 id="unity"><a class="header" href="#unity">Unity</a></h3>
<p>Consumes Unity packages processing all meshes, textures and materials, and LoD levels into a normalized form to consume in Ambient.
Usage of a processed model during runtime is identical to <code>Regular</code>.</p>
<h3 id="quixel"><a class="header" href="#quixel">Quixel</a></h3>
<p>Imports Quixel packages.</p>
<p>Supports collections, LoD levels, etc.</p>
<h2 id="materials-1"><a class="header" href="#materials-1">Materials</a></h2>
<p>Import materials from a variety of formats. Overrides can be specified in the pipeline.</p>
<p>Detailed documentation is pending, but please consult the <a href="reference/asset_pipeline.html#reference">Reference</a>.</p>
<h3 id="supported-formats-2"><a class="header" href="#supported-formats-2">Supported formats</a></h3>
<ul>
<li><code>jpg</code></li>
<li><code>png</code></li>
<li><code>gif</code></li>
<li><code>webp</code></li>
<li>as well as other common image formats</li>
</ul>
<h2 id="audio"><a class="header" href="#audio">Audio</a></h2>
<p>Detailed documentation is pending, but please consult the <a href="reference/asset_pipeline.html#reference">Reference</a>.</p>
<h3 id="supported-formats-3"><a class="header" href="#supported-formats-3">Supported formats</a></h3>
<ul>
<li><code>ogg</code></li>
<li><code>wav</code></li>
<li><code>mp3</code></li>
</ul>
<h2 id="reference-1"><a class="header" href="#reference-1">Reference</a></h2>
<p>See <code>rustdoc</code> for a complete reference of supported pipelines, model importers, material configurations,
and the like.</p>
<pre><code class="language-sh">cargo doc --open -p ambient_pipeline_types
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="networking-1"><a class="header" href="#networking-1">Networking</a></h1>
<p>Networking is a critical component of Ambient, as it enables communication between the client and the server. This document explains some of the specifics behind the current protocol.</p>
<h2 id="protocol"><a class="header" href="#protocol">Protocol</a></h2>
<p>Currently, the Ambient runtime only supports desktop clients and uses QUIC through the <code>quinn</code> library as its communication protocol. We are actively working on web deployments and plan to use WebTransport as soon as possible.</p>
<p>The HTTP (TCP) port is <code>8999</code>, and the QUIC (UDP) port is <code>9000</code>.</p>
<h2 id="entities-1"><a class="header" href="#entities-1">Entities</a></h2>
<p>The Ambient runtime synchronizes all entities with at least one component marked with the <code>Networked</code> attribute. Only components marked as <code>Networked</code> will be sent to the client. Most core components are <code>Networked</code>, but custom components are not by default; this is something developers have to opt into. It is important to note that this may have unintended ramifications in terms of cheating, especially for hostile clients.</p>
<p>The client is fundamentally designed around runtime flexibility of logic, which is non-ideal for avoiding cheaters. Further research and development are required, but it is likely that there is no silver bullet, and the solution will be game-dependent.</p>
<p>If on 0.2 or above, consult the <a href="https://github.com/AmbientRun/Ambient/blob/main/guest/rust/examples/intermediate/clientside/ambient.toml">clientside</a> example to see how to define networked components.</p>
<h2 id="logic-and-prediction"><a class="header" href="#logic-and-prediction">Logic and Prediction</a></h2>
<p>All gameplay logic is currently server-authoritative. We currently do not have any form of latency-hiding, including prediction, rollback, or clientside logic. We previously had rollback but it was removed due to its relative inflexibility (the solution would have to be different for each class of game.)</p>
<p>Our plan is to introduce clientside and shared logic that can be used for user-defined prediction with runtime assistance, but this will take some time.</p>
<h2 id="messaging"><a class="header" href="#messaging">Messaging</a></h2>
<p>The Ambient runtime supports messaging from the client to the server and vice versa through structured messages. These messages are defined ahead of time in <code>ambient.toml</code> and made accessible to code that consumes that <code>ambient.toml</code>. This messaging can be reliable (QUIC unistream) or unreliable (QUIC datagram). Developers can use this to define their networked behavior, including customized prediction.</p>
<p>If on 0.2 or above, consult the <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/intermediate/messaging">messaging</a> example to see how to use the messaging functionality.</p>
<h2 id="proxy"><a class="header" href="#proxy">Proxy</a></h2>
<p>Since 0.2, Ambient will establish a connection to a NAT traversal proxy by default (this can be turned off with <code>--no-proxy</code>). This proxy allows users to connect to an Ambient server, even when the server is behind NAT or similar. Check the <a href="https://github.com/AmbientRun/AmbientProxy">AmbientProxy repository</a> for more details about the proxy itself.</p>
<p>The Ambient server (i.e. Ambient when started with <code>run</code> or <code>serve</code>) connects to the proxy using QUIC (using the <code>quinn</code> library) and allocates a proxy endpoint. In response, the proxy provides the endpoint's details as well as an URL for asset downloading. The allocated proxy endpoint can be used by players to connect (<code>ambient join ...</code>) to the game server, even if it is running behind a NAT.</p>
<p>Communication between the proxy and players uses the same protocol as with a direct connection to the Ambient server; the only difference is the proxy acting as an intermediary.</p>
<h2 id="certificates"><a class="header" href="#certificates">Certificates</a></h2>
<p>By default, Ambient bundles a self-signed certificate that is used by the server and trusted by the client.</p>
<p>To use your own certificate:</p>
<ul>
<li>specify <code>--cert</code> and <code>--key</code> for the server:
<pre><code class="language-sh">ambient serve --cert ./localhost.crt --key ./localhost.key
</code></pre>
</li>
<li>specify <code>--ca</code> for the client if the certificate authority that signed the certificate is not present within the client's system roots
<pre><code class="language-sh">ambient join 127.0.0.1:9000
</code></pre>
</li>
</ul>
<p>If a custom certificate is specified, the bundled certificates will <em>not</em> be used as a fallback.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="animations"><a class="header" href="#animations">Animations</a></h1>
<p>See the <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/basics/skinmesh">skinmesh example</a> for a complete example.</p>
<h2 id="animation-assets"><a class="header" href="#animation-assets">Animation assets</a></h2>
<p>To work with animations, you will need some animation clips. A good way to get started is
by going to <a href="https://www.mixamo.com/#/">Mixamo</a> and downloading some characters and animations.</p>
<p>In the <code>assets</code> folder of your ember, place your models and animations. Additionally, in the same folder,
make sure you have a <code>pipeline.toml</code> which can process models and animations:</p>
<pre><code class="language-toml">[[pipelines]]
type = &quot;Models&quot;
</code></pre>
<h3 id="finding-the-clip-urls"><a class="header" href="#finding-the-clip-urls">Finding the clip URLs</a></h3>
<p>The <code>ambient build</code> command will build the assets. You can browse the <code>build/assets</code> folder to see what
was produced by the command.</p>
<p>As an example:</p>
<ul>
<li>The <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/basics/skinmesh">skinmesh example</a>
has an animation called <code>assets/Capoeira.fbx</code>.</li>
<li>The build process will produce <code>build/assets/Capoeira.fbx/animations/mixamo.com.anim</code>.</li>
<li>The animation clip URL is this path without <code>build/</code>: <code>assets/Capoeira.fbx/animations/mixamo.com.anim</code>.</li>
</ul>
<h2 id="animation-player"><a class="header" href="#animation-player">Animation player</a></h2>
<p>An <code>AnimationPlayer</code> is used to play animations. The player executes a graph of animation nodes; at present,
the two nodes that exist are <code>PlayClipFromUrlNode</code> and <code>BlendNode</code>.</p>
<p>Here's an example of how to set up a graph and play it for a single animation:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let clip = PlayClipFromUrlNode::new(
    asset::url(&quot;assets/Capoeira.fbx/animations/mixamo.com.anim&quot;).unwrap()
);
let player = AnimationPlayer::new(&amp;clip);

// Let's load a character model to apply the animation to.
Entity::new()
    .with_merge(make_transformable())
    .with(prefab_from_url(), asset::url(&quot;assets/Peasant Man.fbx&quot;).unwrap())
    .with(apply_animation_player(), player.0)
    .spawn();
<span class="boring">}
</span></code></pre></pre>
<p>The same animation player can be attached to multiple models.</p>
<h3 id="blending-animations-together"><a class="header" href="#blending-animations-together">Blending animations together</a></h3>
<p>A <code>BlendNode</code> can be used to blend two animations together:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let capoeira = PlayClipFromUrlNode::new(
    asset::url(&quot;assets/Capoeira.fbx/animations/mixamo.com.anim&quot;).unwrap()
);
let robot = PlayClipFromUrlNode::new(
    asset::url(&quot;assets/Robot Hip Hop Dance.fbx/animations/mixamo.com.anim&quot;).unwrap()
);
let blend = BlendNode::new(&amp;capoeira, &amp;robot, 0.3);
let anim_player = AnimationPlayer::new(&amp;blend);
<span class="boring">}
</span></code></pre></pre>
<p>This will blend <code>capoeira</code> (30%) and <code>robot</code> (70%) together to form one output animation.</p>
<h3 id="masked-blending"><a class="header" href="#masked-blending">Masked blending</a></h3>
<p>A common use case for blending is to blend two animations together for different parts of the body;
this is achieved using masking. Here's an example of how to blend two animations together for the upper and lower
body:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let capoeira = PlayClipFromUrlNode::new(
    asset::url(&quot;assets/Capoeira.fbx/animations/mixamo.com.anim&quot;).unwrap()
);
let robot = PlayClipFromUrlNode::new(
    asset::url(&quot;assets/Robot Hip Hop Dance.fbx/animations/mixamo.com.anim&quot;).unwrap()
);

let blend = BlendNode::new(&amp;capoeira, &amp;robot, 0.0);
blend.set_mask_humanoid_lower_body(1.0);

let anim_player = AnimationPlayer::new(&amp;blend);
<span class="boring">}
</span></code></pre></pre>
<p>This will play the <code>capoeira</code> at the upper body, and the <code>robot</code> dance for the lower body.
The <code>set_mask_humanoid_lower_body</code> and <code>set_mask_humanoid_upper_body</code> functions are convenience
functions for setting the mask for the upper and lower body.</p>
<p>The blend node's weight is still relevant when used with masking, but can also be set per-bone using the mask.
Setting <code>BlendNode::new(&amp;capoeira, &amp;robot, 0.3)</code> and then <code>blend.set_mask_humanoid_lower_body(0.9)</code> will play all
nodes in the <code>capoeira</code> animation at 30%, except for the lower body, which will play it at 90%. If no mask is set,
the weight is used for all bones.</p>
<h3 id="attaching-entities-to-a-skeleton"><a class="header" href="#attaching-entities-to-a-skeleton">Attaching entities to a skeleton</a></h3>
<p>Entities can be attached to bones on a skeleton. This is done by adding a <code>parent</code> component to the entity that
points to the bone to be attached to. The entity should also have a <code>local_to_parent</code> component, which will be
the transformation of the entity relative to the bone. For more information, see the documentation on <a href="reference/hierarchies.html">hierarchies</a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let left_foot = animation::get_bone_by_bind_id(unit_id, &amp;BindId::LeftFoot).unwrap();
let ball = Entity::new()
    .with_merge(make_transformable())
    .with_merge(make_sphere())
    .with(parent(), left_foot)
    .with_default(local_to_parent())
    // Without reset_scale, the ball would take the scale of the
    // bone we're attaching it to
    .with_default(reset_scale())
    .spawn();
entity::add_child(left_foot, ball);
<span class="boring">}
</span></code></pre></pre>
<p>This will spawn a ball and attach it to the left foot of the character.</p>
<h3 id="pre-loading-animations"><a class="header" href="#pre-loading-animations">Pre-loading animations</a></h3>
<p>Animations can be pre-loaded by creating a <code>PlayClipFromUrlNode</code> node and waiting for it to load:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let capoeira = PlayClipFromUrlNode::new(
    asset::url(&quot;assets/Capoeira.fbx/animations/mixamo.com.anim&quot;).unwrap()
);
capoeira.wait_for_load().await;
<span class="boring">}
</span></code></pre></pre>
<p>The clip will remain loaded as long as the object survives.</p>
<h3 id="retargeting"><a class="header" href="#retargeting">Retargeting</a></h3>
<p>It is possible to play an animation that was made for one character on another character.
Retargeting may be necessary to remap the animation from the original character's skeleton to your target
character's skeleton.</p>
<p>To do this, <code>PlayClipFromUrlNode::set_retargeting</code> can be used to configure the retargeting for a given clip.
Additionally, <code>PlayClipFromUrlNode::apply_base_pose</code> may be necessary to change the origin of the animation
for correctness.</p>
<p>If you're using Mixamo for animations, you can do retargeting through Mixamo itself to get the best results.</p>
<h3 id="animation-nodes-lifetimes-and-ownership"><a class="header" href="#animation-nodes-lifetimes-and-ownership">Animation nodes lifetimes and ownership</a></h3>
<p>The animation player and nodes all live in the ECS. The <code>AnimationPlayer</code>, <code>PlayClipFromUrlNode</code> and other nodes
are wrappers around an <code>EntityId</code>. To remove an animation player, call <code>player.despawn()</code> on it.</p>
<p>The animation nodes are ref-counted, so they will survive while at least one of the following is true:</p>
<ul>
<li>they are either being played by an animation player</li>
<li>they are being referenced by your code (i.e. you have an <code>PlayClipFromUrlNode</code>).</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="audio-1"><a class="header" href="#audio-1">Audio</a></h1>
<p>Ambient has basic audio functionality including sound playback, panning and volume control.</p>
<p>3D audio with HRTF is also included but considered as highly experimental.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>To use audio, you need to put the audio files into the <code>assets</code> folder, and then edit the <code>pipeline.toml</code>.</p>
<p>Check the <code>assets</code> folder in the <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/basics/physics">physics example</a> to see how this is done.</p>
<p>Audio should be loaded and played in clientside WASM/<code>client.rs</code> (the API is not supported on the server). <a href="reference/ember.html#messages--messages">Messages</a> can be used by the server to tell the client to play a sound effect.</p>
<h1 id="examples-with-audio"><a class="header" href="#examples-with-audio">Examples with audio</a></h1>
<ul>
<li><code>./guest/rust/examples/basics/physics</code> (spatial audio)</li>
<li><code>./guest/rust/examples/basics/first_person_camera</code> (spatial audio)</li>
<li><code>./guest/rust/examples/games/music_sequencer</code></li>
<li><code>./guest/rust/examples/ui/audio_ctrl</code></li>
</ul>
<p>The general idea is that in the ECS system, you can create an <code>audio::AudioPlayer</code> or <code>audio::SpatialAudioPlayer</code>. You can set the property of these players with methods such as <code>set_amplitude</code>. Then you can use the <code>player</code> to play a sound assets. This will actually return an <code>EntityId</code>. By <code>add_component</code> to the entity, you can control the playing sound as well. The <code>audio_ctrl</code> example shows the details. When the sound playing finishes, the entity will automatically despawn. To stop a playing sound in advance, see the <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/ui/audio_ctrl">audio_ctrl example</a>.</p>
<pre><pre class="playground"><code class="language-rust">pub fn main() {
    let player = audio::AudioPlayer::new();
    player.set_amplitude();
    let playing_sound = player.play(asset::url(&quot;assets/sound.ogg&quot;));
    entity::add_component(playing_sound, amplitude(), 0.1);
}
</code></pre></pre>
<h2 id="deciding-whether-to-convert-audio-formats"><a class="header" href="#deciding-whether-to-convert-audio-formats">Deciding whether to convert audio formats</a></h2>
<p>Currently, we support <code>wav</code>, <code>mp3</code>, and <code>ogg</code> audio file formats. If you use an <code>mp3</code> format, it will be converted to <code>ogg</code> during the build process. However, you can use either &quot;.mp3&quot; or &quot;.ogg&quot; in the <code>asset::url</code> function.</p>
<p>In some cases, you may want to explicitly control whether the audio is converted in order to save space or maintain the best audio quality. This is particularly relevant for <code>wav</code> files, which are large when unconverted but offer lossless playback. You can manage this setting in the <code>pipeline.toml</code> file.</p>
<pre><code class="language-toml">[[pipelines]]
type = &quot;Audio&quot;
convert = true
</code></pre>
<p>If you convert a <code>wav</code> file, then you need to use <code>.ogg</code> in <code>asset::url</code>.
If the <code>convert</code> entry is missing, the default behaviour is no conversion.</p>
<h2 id="debug-spatial-audio"><a class="header" href="#debug-spatial-audio">Debug (spatial) audio</a></h2>
<p>In some cases, e.g. an FPS game, you want to test how one client's movement sounds to the other client. Then use <code>--mute-audio</code> flag with <code>ambient</code> cli. For example:</p>
<pre><code>ambient run --mute-audio
</code></pre>
<p>This will mute the client opened with this command while the rest clients won't be influenced.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ui"><a class="header" href="#ui">UI</a></h1>
<p>Ambient's UI system is heavily inspired by React (with hooks), and follows many of the same patterns.
Take a look at the <a href="https://react.dev/reference/react">React documentation</a> to learn how hooks work in general.</p>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting started</a></h2>
<p>Here's a complete example of a minimal counter app:</p>
<pre><pre class="playground"><code class="language-rust">use ambient_api::prelude::*;
use ambient_ui::prelude::*;

#[element_component]
fn App(hooks: &amp;mut Hooks) -&gt; Element {
    let (count, set_count) = hooks.use_state(0);
    FlowColumn::el([
        Text::el(format!(&quot;We've counted to {count} now&quot;)),
        Button::new(&quot;Increase&quot;, move |_| set_count(count + 1)).el(),
    ])
}

#[main]
pub fn main() {
    App.el().spawn_interactive();
}
</code></pre></pre>
<p><a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/ui">See all UI examples here</a>.</p>
<h2 id="layout"><a class="header" href="#layout">Layout</a></h2>
<p>The layout is roughly based on <a href="https://docs.microsoft.com/en-us/dotnet/desktop/winforms/controls/layout?view=netdesktop-6.0#container-flow-layout">Windows Forms</a>.</p>
<p>There are two major layout components, <code>Dock</code> and <code>Flow</code> (which includes <code>FlowColumn</code> and <code>FlowRow</code>).</p>
<p><code>Dock</code> is top-down: it starts with a given area (say the screen) and then divides it into smaller pieces with each new element added to it.</p>
<p><code>Flow</code> is bottom-up: it auto-resizes itself to fit its constituent components.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terminology"><a class="header" href="#terminology">Terminology</a></h1>
<p>A brief list of terms used by Ambient and their definitions. This is incomplete - let us know if there's anything you need clarified!</p>
<ul>
<li><strong>Concept</strong>: A collection of components defined in an <code>ambient.toml</code> that, when present together, imply something about the entity they're attached to. Similar to Go's interfaces.</li>
<li><strong>ECS</strong>: <a href="https://en.wikipedia.org/wiki/Entity_component_system">https://en.wikipedia.org/wiki/Entity_component_system</a></li>
<li><strong><code>ElementComponent</code></strong>: A piece of UI that can be rendered. Similar to React's Components.</li>
<li><strong>Prefab</strong>: A entity or group of entities. Often an entity with a model and a collider attached to it.</li>
<li><strong>PVD</strong>: <a href="https://developer.nvidia.com/physx-visual-debugger">PhysX Visual Debugger</a>.</li>
<li><strong>WASM/WebAssembly</strong>: <a href="https://webassembly.org/">https://webassembly.org/</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common pitfalls</a></h1>
<p>Be aware that a lot of problems are caused by mismatching versions of Ambient. To check your version, run <code>ambient --version</code> and make sure it matches the version in your <code>Cargo.toml</code> file.</p>
<h2 id="the-examples-dont-work"><a class="header" href="#the-examples-dont-work">The examples don't work</a></h2>
<p>This is most often because of mismatching the ambient version with the
examples version. See <a href="reference/../user/running_examples.html">running examples</a>.</p>
<h2 id="my-clientside-wasm-module-crashes-when-accessing-a-component-from-the-server-and-unwrapping-it"><a class="header" href="#my-clientside-wasm-module-crashes-when-accessing-a-component-from-the-server-and-unwrapping-it">My clientside WASM module crashes when accessing a component from the server and unwrapping it</a></h2>
<p>Your clientside WASM can run before the server has finished running its WASM, so the component you're trying to access may not have been created yet.</p>
<p>To fix this, consider using <code>entity::wait_for_component</code>, which is an async helper that will stall execution until the component is available.</p>
<h2 id="my-object-with-a-random-color-is-black-sometimes"><a class="header" href="#my-object-with-a-random-color-is-black-sometimes">My object with a random color is black sometimes</a></h2>
<p>The <code>color</code> component is a <code>Vec4</code>. Using <code>rand::random</code> to populate it will
result in the <code>w</code>/alpha channel also being between 0 and 1, which means your
object may be black and/or disappear if the alpha is below the default alpha
cut-off.</p>
<p>To fix this, use a random <code>Vec3</code> for your color and then extend it to a <code>Vec4</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let color = rand::random::&lt;Vec3&gt;().extend(1.0);
<span class="boring">}
</span></code></pre></pre>
<h2 id="fails-to-start-on-linux-error-in-surfaceconfigure-parent-device-is-lost"><a class="header" href="#fails-to-start-on-linux-error-in-surfaceconfigure-parent-device-is-lost">Fails to start on Linux (Error in <code>Surface::configure: parent device is lost</code>)</a></h2>
<p>If you're running Wayland, you may have to start ambient with: <code>WAYLAND_DISPLAY=wayland-1 ambient run</code>.
See <a href="https://github.com/gfx-rs/wgpu/issues/2519">this issue</a> for details.</p>
<h2 id="runtime-error-import--has-the-wrong-type"><a class="header" href="#runtime-error-import--has-the-wrong-type">Runtime error: import <code>...</code> has the wrong type</a></h2>
<p>This can occur when you have <code>.wasm</code> files in your <code>build</code> folder that are using an old version of the Ambient API.
Delete the <code>build</code> folder and try again - this should force them to be regenerated.</p>
<h2 id="failed-to-download-file--error-trying-to-connect-tcp-connect-error-etc-os-error-10060"><a class="header" href="#failed-to-download-file--error-trying-to-connect-tcp-connect-error-etc-os-error-10060">Failed to download file / error trying to connect: tcp connect error: <em>etc</em> (OS error 10060)</a></h2>
<p>This can happen if your anti-virus or firewall is blocking the connection to the Ambient runtime.
Try deactivating it, then run the Ambient ember again with 'ambient run'.</p>
<p>If this fixes it, you'll need to add an exception to your anti-virus/firewall to allow Ambient to connect.
We do not recommend leaving your anti-virus/firewall disabled.</p>
<h2 id="ciso646-not-found"><a class="header" href="#ciso646-not-found"><code>&lt;ciso646&gt;</code> not found</a></h2>
<p>The compilation of <code>physx-sys</code> and other C++ libraries may fail due to a missing <code>ciso646</code> header.
This header was removed as part of C++20, and distributions no longer ship it by default.</p>
<p>This can be fixed on Debian-based distributions (i.e. Ubuntu 22.04, Pop!_OS 22.04, etc) by running</p>
<pre><code class="language-sh">sudo apt install libstdc++-12-dev
</code></pre>
<p>to install a version of the GNU C++ standard library that includes the header.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="should-my-code-go-on-the-client-or-the-server"><a class="header" href="#should-my-code-go-on-the-client-or-the-server">Should my code go on the client or the server?</a></h2>
<p>The Ambient API is split into two parts: the client and the server. The client is the code that runs on the player's machine, and the server is the code that runs on the host's machine. The client is responsible for rendering the game, and for sending input to the server. The server is responsible for running the game simulation, and for sending the client information about the game state.</p>
<p>When you create an ember, both <code>client</code> and <code>server</code> modules are created. You can put code in either of these modules, and it will be run on the client or the server, respectively. In general, code that runs on the server should be authoritative, and code that runs on the client should be visual. What the server says should be the source of truth for all players.</p>
<p>The ECS can be used to synchronize state between the server and the client. Both the client and the server have the same ECS, but components with the <code>Networked</code> attribute will be synchronized from the server to the client. The client can make its own changes to the ECS, including adding and modifying components, but any modified components will be overridden by the server's version when the server sends an update for those components.</p>
<p>Additionally, both the client and the server can send structured messages to each other to communicate information that can't be represented in the ECS. For more information on this, see the <a href="reference/ember.html#messages--messages">ember documentation</a>.</p>
<p>Deciding where your code should go is important to making the most of Ambient, and it's not always obvious. Here are some guidelines:</p>
<p>If you are doing any of the following, your code should go on the client:</p>
<ul>
<li>Rendering UI</li>
<li>Visual changes that should only be visible to the player</li>
<li>Capturing input</li>
<li>Playing sounds</li>
<li>Predicting the game state for better user experience</li>
<li>Visual effects that don't need to be replicated exactly (particle systems, etc)</li>
</ul>
<p>If you are doing any of the following, your code should go on the server:</p>
<ul>
<li>Moving a character</li>
<li>Calculating damage</li>
<li>Spawning or updating entities</li>
<li>Changing the game state</li>
<li>Communicating with external services</li>
<li>Anything that should be authoritative</li>
<li>Anything that should be hidden from the player</li>
</ul>
<p>If you are doing any of the following, your code could go on either the client or the server, or be shared between them:</p>
<ul>
<li>Shared calculations (e.g. determining the color of a player's nameplate from the player's name)</li>
<li>Shared data structures</li>
<li>Shared constants</li>
<li>Shared utility functions</li>
<li>Shared types</li>
</ul>
<p>Consider looking at the game examples for more information on how to structure your code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>We welcome community contributions to this project.</p>
<p>Please talk with us on Discord beforehand if you'd like to contribute a larger piece of work. This is particularly important if your contribution involves adding new functionality to the host; our goal is to implement as much functionality on the guest as possible, so that the host can remain simple and enable a wide variety of use cases without being too opinionated.</p>
<h2 id="campfire"><a class="header" href="#campfire">Campfire</a></h2>
<p>Campfire is our internal tool for working with the repository. It has several commands that can be used to help with development, which you can find by running <code>cargo campfire --help</code>.</p>
<p>It is also aliased to <code>cargo cf</code> for convenience.</p>
<p>Running an example can be done like this:</p>
<pre><code class="language-sh">cargo cf run decals
</code></pre>
<p>By default, Campfire will build Ambient with the <code>debug</code> profile. To build with the <code>release</code> profile and to build the assets with <code>--relase</code>, use the <code>--release</code> flag before the example and after:</p>
<pre><code class="language-sh">cargo cf run --release decals -- --release
</code></pre>
<h2 id="api-docs"><a class="header" href="#api-docs">API docs</a></h2>
<p>To see the latest version of the API docs, run the following command in the <code>Ambient</code> repository:</p>
<pre><code class="language-sh">cargo campfire doc api --open
</code></pre>
<h2 id="installing-1"><a class="header" href="#installing-1">Installing</a></h2>
<p>As a developer, you may find yourself needing to install (a specific version of) Ambient on your system. This can be done with the following command:</p>
<pre><code>cargo campfire install [--git-revision &lt;revision&gt;] [--git-tag &lt;tag&gt;]
</code></pre>
<p>If no revision or tag is specified, the version of Ambient in the current directory will be installed.</p>
<h2 id="adding-to-the-api"><a class="header" href="#adding-to-the-api">Adding to the API</a></h2>
<p>Our bindings are defined in <a href="https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md">WIT</a>, which is a language-independent interface definition language for defining WebAssembly interfaces.
They are found in the <a href="https://github.com/AmbientRun/Ambient/tree/main/crates/wasm/wit"><code>crates/wasm/wit</code></a> folder.
At present, there is only one WIT world, <code>bindings</code>, in the <code>main.wit</code> folder, and it is used for both the client and server bindings.</p>
<p>These bindings are wired up in the host using <a href="https://docs.wasmtime.dev/api/wasmtime/component/index.html"><code>wasmtime</code>'s Component Model support</a>.
The WIT interfaces generate traits, which are then implemented within <a href="https://github.com/AmbientRun/Ambient/tree/main/crates/wasm/src/client/mod.rs">crates/wasm/src/client/mod.rs</a> and <a href="https://github.com/AmbientRun/Ambient/tree/main/crates/wasm/src/server/mod.rs">crates/wasm/src/server/mod.rs</a>. As all interfaces need to be implemented - even when not relevant to the side of the network boundary you're on - unused implementations go in the <code>unused.rs</code> module in the same folder.</p>
<p>Note that the bindings use <code>async fn</code>s in the traits - this is a side-effect of <code>wasmtime-wasi</code> preview2 being async-only. Do <em>not</em> attempt to use async functionality in your implementations; it will not work.</p>
<p>Types that are shared between interfaces should go in <code>types.wit</code>; otherwise, they should go in the relevant interface file. Where possible, try to describe as much within the WIT files; the more that is specified in the WIT files, the less code needs to be written for each guest language.</p>
<p>If you add a new interface, you will need to expose it in <code>main.wit</code>, update <code>crates/wasm/src/shared/bindings.rs</code> to include it in <code>BindingsBound</code>, and add implementations for the new trait in <code>crates/wasm/src/client/mod.rs</code> and <code>crates/wasm/src/server/mod.rs</code>.</p>
<p>On the host, add implementations of <code>IntoBindgen</code> and <code>FromBindgen</code> for your WIT type. This is typically done in a <code>conversion.rs</code>. This allows you to use the type in the host code with the usual affordances, while still being able to pass it to the guest.</p>
<h3 id="guest-considerations"><a class="header" href="#guest-considerations">Guest considerations</a></h3>
<p>At present, we only support Rust as a guest language, but we want to improve this in future. The following advice applies only to Rust.</p>
<hr />
<p>The WIT bindings are automatically generated by the host's <code>ambient_wasm</code> build script. This build script runs <a href="https://github.com/bytecodealliance/wit-bindgen"><code>wit-bindgen</code></a> as a library and updates <code>guest/rust/api_core/src/internal/bindings.rs</code> with the generated code. You may need to build the host in order to update the guest API code after making changes to the WIT files, but running <code>cargo check</code> (including through your IDE on save) should be sufficient to trigger this process.</p>
<p>When merging code that changes the bindings, there may be a conflict in the generated <code>bindings.rs</code> file. In this case, delete the file and run <code>cargo check -p ambient_wasm</code> (or a similar command that will run <code>ambient_wasm</code>'s build script) to force regeneration of the file.</p>
<p>Where relevant/possible, use native types and convert to/from the WIT types with <code>IntoBindgen</code>/<code>FromBindgen</code>. This allows both API developers and users to use the type they would expect (e.g. <code>glam::Vec3</code> instead of the WIT-generated <code>Vec3</code>), and to extend it with additional methods where required.</p>
<p>This means that if you define a</p>
<pre><code class="language-wit">record ray {
    origin: vec3,
    direction: vec3,
}
</code></pre>
<p>you should also consider defining</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Some documentation
struct Ray {
    // Per-field
    origin: Vec3,
    // Documentation
    direction: Vec3,
}
impl IntoBindgen for Ray {
    type Item = wit::types::Ray;
    fn into_bindgen(self) -&gt; Self::Item {
        wit::types::Ray {
            origin: self.origin.into_bindgen(),
            direction: self.direction.into_bindgen(),
        }
    }
}
impl FromBindgen for wit::types::Ray {
    type Item = Ray;
    fn from_bindgen(self) -&gt; Self::Item {
        Ray {
            origin: self.origin.from_bindgen(),
            direction: self.direction.from_bindgen(),
        }
    }
}
impl Ray {
    /* helper methods */
}
<span class="boring">}
</span></code></pre></pre>
<p>so that you can provide Rust-specific features. Where possible, try to avoid exposing the WIT types to the user, and try to keep as much functionality in WIT to ensure other guest languages can benefit from it.</p>
<h2 id="adding-a-new-supported-component-type"><a class="header" href="#adding-a-new-supported-component-type">Adding a new supported component type</a></h2>
<p>Components and their values are the core unit of data exchange in Ambient. We try to keep to a core set of types as adding more types results in some amount of bloat (especially with the amount of code generated); however, adding a new type is often the best way to represent a specific kind of data.</p>
<p>To do so, you will need to update the following files:</p>
<h3 id="core-definitions"><a class="header" href="#core-definitions">Core definitions</a></h3>
<ul>
<li><code>crates/wasm/wit/component.wit</code>: Add the new type to the three <code>value</code> enums.</li>
<li><code>shared_crates/shared_types/src/lib.rs</code>: Add the new type to the <code>primitive_component_definitions</code> definition.</li>
</ul>
<h3 id="code-generation"><a class="header" href="#code-generation">Code generation</a></h3>
<ul>
<li><code>shared_crates/project_macro_common/src/component.rs</code>: Specify how to generate the type definition for <code>convert_primitive_type_to_rust_type</code>.</li>
<li><code>shared_crates/project_macro_common/src/concept.rs</code>: Specify how to generate Rust code for a value of the type from TOML in <code>toml_value_to_tokens_primitive</code>.</li>
</ul>
<h3 id="runtime-support"><a class="header" href="#runtime-support">Runtime support</a></h3>
<ul>
<li><code>shared_crates/project_rt/src/message_serde.rs</code>: Specify how to serialize and deserialize the type to a binary stream.</li>
</ul>
<h3 id="utilities"><a class="header" href="#utilities">Utilities</a></h3>
<ul>
<li><code>crates/wasm/src/shared/conversion.rs</code>: Add <code>IntoBindgen</code>/<code>FromBindgen</code> implementations if appropriate.</li>
<li><code>guest/rust/api_core/src/internal/conversion.rs</code>: Add <code>IntoBindgen</code>/<code>FromBindgen</code> implementations if appropriate.</li>
</ul>
<h3 id="documentation"><a class="header" href="#documentation">Documentation</a></h3>
<ul>
<li><code>CHANGELOG.md</code>: Document the addition of the new supported type.</li>
<li><code>docs/src/reference/ambient.sample.toml</code>: Document the new type in the sample TOML file.</li>
<li><code>docs/src/reference/project.md</code>: Document the new type in the components section.</li>
</ul>
<h2 id="golden-image-tests"><a class="header" href="#golden-image-tests">Golden image tests</a></h2>
<p>Golden image tests are a type of end-to-end test where a rendered image is captured and compared against an existing known-good image. This test is ran in our CI against all PRs, but you can also run it locally with <code>cargo campfire golden-images</code>.</p>
<h3 id="golden-images-on-ci"><a class="header" href="#golden-images-on-ci">Golden images on CI</a></h3>
<p>To debug why the CI fails, download the <code>screenshots.zip</code> file from the build artifacts, and look in the logs of the CI.
The <code>screenshots.zip</code> will show what image the CI produced.</p>
<h3 id="running-golden-images-locally"><a class="header" href="#running-golden-images-locally">Running golden images locally</a></h3>
<p>To update golden images, run <code>cargo campfire golden-images update</code>. This renders and saves a new set of golden images and replaces existing images.
To check against existing golden images, run <code>cargo campfire golden-images check</code>. This renders a new set of golden images and compares against existing images using a perceptual image difference metric.</p>
<h3 id="filtering-tests"><a class="header" href="#filtering-tests">Filtering tests</a></h3>
<p>Running <code>cargo campfire golden-images --prefix ui check</code> will only check tests which begin with <code>ui</code> prefix.</p>
<h3 id="common-failures"><a class="header" href="#common-failures">Common failures</a></h3>
<ul>
<li>If your test includes anything that animates over time, this is likely to fail the golden image test because the current golden image test implementation waits for a brief moment before capturing the image. During this moment, the animation might advance to a state which causes golden image test to fail. Therefore all tests should be static by default.</li>
</ul>
<h3 id="flakiness"><a class="header" href="#flakiness">Flakiness</a></h3>
<p>There are known situations where a test might fail seemingly randomly, even if the images look perceptually identical. These situations include:</p>
<ul>
<li>The golden image was generated on a real graphics hardware, for example on the contributors computer, while the CI version runs <code>llvmpipe</code> which is a software rasterizer. This might cause small imperceptible differences. There are currently no clean solutions to this other than increasing the error threshold.</li>
<li>Timing out. Each test runs with a timeout setting which could happen if the test takes too long to produce an image. On a powerful enough local machine this might not be an issue, but runtimes might be more unpredictable in Github Actions. In these cases we can either increase the timeout or see if we can optimize the test.</li>
</ul>
<h2 id="releasing"><a class="header" href="#releasing">Releasing</a></h2>
<ol>
<li>Run <code>cargo campfire release update-version new_version_here</code> to update the Ambient version across the crates and documentation.</li>
<li>Run <code>cargo campfire doc runtime</code> to update the documentation from the codebase.</li>
<li>If a new system dependency was added, ensure it is added to <code>docs/src/installing.md</code> and <code>Dockerfile</code>.</li>
<li>Run <code>cargo campfire example check-all</code> and ensure all guest projects build without errors.</li>
<li>Run <code>cargo campfire example run-all</code> and visually verify that they work as expected.</li>
<li>Use <code>cargo campfire release check</code> to check that the release is ready.</li>
<li>Update the <code>CHANGELOG.md</code> at the root of the repository. Copy the unreleased block, set the version and date on the copy, and then empty out the unreleased block for the next release.</li>
<li>Make a commit with the above changes, and create a tag <code>v0.X.Y</code>.</li>
<li>Push to origin.</li>
<li>If this is a new major release (e.g. <code>0.2.0</code>), immediately update the version using <code>cargo campfire release update-version</code> to the next major release suffixed by dev (e.g. <code>0.3.0-dev</code>) and push that up (but do not tag it). This is to disambiguate in-development major releases from stable ones. If we need to update the released version, we will branch off from the release, cherry-pick relevant hotfixes, and cut a new release from that branch.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><!-- markdownlint-disable-file MD041 -->
<h1 id="changelog"><a class="header" href="#changelog">Changelog</a></h1>
<!-- markdownlint-disable-file MD024 -->
<p>This changelog is manually updated. While an effort will be made to keep the <a href="community/changelog.html#unreleased-yyyy-mm-dd">Unreleased</a> changes up to date, it may not be fully representative of the current state of the project.</p>
<!-- If you are updating this file, make sure you copy the unreleased section and change the version and date. Do not remove it. -->
<!--
## Unreleased (YYYY-MM-DD)

### Added

#### Headline features

#### Other

#### Examples

### Changed

#### Breaking

#### Non-breaking

### Fixed

### Community PRs to internals

These PRs are not directly user-facing, but improve the development experience. They're just as appreciated!

### Removed
-->
<h2 id="version-030-dev-yyyy-mm-dd"><a class="header" href="#version-030-dev-yyyy-mm-dd">Version 0.3.0-dev (YYYY-MM-DD)</a></h2>
<h3 id="added"><a class="header" href="#added">Added</a></h3>
<h4 id="headline-features"><a class="header" href="#headline-features">Headline features</a></h4>
<ul>
<li><strong>Client</strong>: The client can now <strong>run on the web</strong>.</li>
<li><strong>Deploy</strong>: The <code>ambient deploy</code> command can now be used to deploy a project to the Ambient runtime services.</li>
<li><strong>Audio</strong>: Spatial audio is now supported for 3D sounds. See the <a href="https://github.com/AmbientRun/Ambient/blob/main/guest/rust/examples/basics/physics/src/client.rs">physics example</a> and <a href="https://github.com/AmbientRun/Ambient/blob/main/guest/rust/examples/basics/first_person_camera/src/client.rs">first_person_camera example</a></li>
<li><strong>Networking</strong>: The networking protocol now supports WebTransport for the web client.</li>
<li><strong>Rendering</strong>: Procedural meshes, textures, samplers and materials are no supported on the client. See the <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/basics/procedural_generation">procedural generation example</a>.</li>
</ul>
<h4 id="other"><a class="header" href="#other">Other</a></h4>
<ul>
<li><strong>UI</strong>: Added a new <code>ImageFromUrl</code> element, which can load images from assets or URLs. It also supports rounded corners, borders and a fallback background color. See the <a href="https://github.com/AmbientRun/Ambient/blob/main/guest/rust/examples/ui/image/src/client.rs">image example</a> for more details.</li>
<li><strong>Rendering</strong>: Added a <code>torus</code> primitive. Thanks to <a href="https://github.com/mebyz">@mebyz</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/376">#376</a>!</li>
<li><strong>Physics</strong>: Add <code>set_character_controller_position</code> to the <code>physics</code> API. Thanks to <a href="https://github.com/devjobe">@devjobe</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/398">#398</a>.</li>
<li><strong>ECS</strong>: <code>Duration</code> is now a supported primitive type.</li>
<li><strong>ECS</strong>: All integer types from 8-bit to 64-bit are now supported as component types, including signed and unsigned variants. Additionally, all signed and unsigned integer vector types are now supported. This includes <code>U16</code>, <code>IVec2</code>, <code>UVec3</code>, etc.</li>
<li><strong>Docs</strong>: The IDE documentation has been improved, including information on how to set up Emacs for Ambient development (thanks to <a href="https://github.com/kevzettler">@kevzettler</a> in <a href="https://github.com/AmbientRun/Ambient/pull/505">#505</a>).</li>
<li><strong>Assets</strong>: Now you can use <code>ambient assets import</code> to import asset one by one. This will create or modify the <code>pipeline.toml</code> file for you.</li>
</ul>
<h4 id="examples-1"><a class="header" href="#examples-1">Examples</a></h4>
<ul>
<li><strong>Clock</strong>: An analog <code>clock</code> example has been added to test line rendering.</li>
<li><strong>Audio control</strong>: An <code>audio_ctrl</code> example has been added to shwo the new audio API usage with UI.</li>
</ul>
<h3 id="changed"><a class="header" href="#changed">Changed</a></h3>
<h4 id="breaking"><a class="header" href="#breaking">Breaking</a></h4>
<ul>
<li><strong>API</strong>: Locally-broadcasted messages can now choose to include the originating module in the broadcast; this is an additional boolean parameter to <code>ModuleMessage::send_local_broadcast</code> and <code>message::Target::LocalBroadcast</code>.</li>
<li><strong>Audio</strong>: Audio API has completely changed to adapt to the ECS style. See the <a href="https://ambientrun.github.io/Ambient/reference/audio.html">audio documentation</a> for the new usage. A CLI option <code>--mute-audio</code> is also added.</li>
<li><strong>Camera</strong>: Renamed <code>screen_to_world_direction</code> to <code>screen_position_to_world_ray</code> and <code>clip_space_ray</code> to <code>clip_position_to_world_ray</code>. See <a href="https://github.com/AmbientRun/Ambient/issues/410">#410</a>.</li>
<li><strong>Physics</strong>: Renamed the <code>visualizing</code> component to <code>visualize_collider</code>.</li>
<li><strong>Animation</strong>: The animation system has been reworked. See the <a href="https://ambientrun.github.io/Ambient/reference/animations.html">animation documentation</a> for details. Thanks to <a href="https://github.com/devjobe">@devjobe</a> for laying the foundation for this!</li>
<li><strong>Physics</strong>: Renamed <code>box_collider</code> to <code>cube_collider</code>.</li>
<li><strong>API</strong>: The <code>time</code> function has been split into <code>game_time</code> and <code>epoch_time</code>. The <code>dtime</code> component has been renamed to <code>delta_time</code>. The <code>frametime</code> function has been renamed to <code>delta_time</code>.</li>
<li><strong>Project</strong>: Projects have been renamed to Embers; see the <a href="https://ambientrun.github.io/Ambient/reference/ember.html">ember documentation</a> for details.</li>
<li><strong>Assets</strong>: Asset pipelines now use TOML instead of JSON. Use the <code>ambient assets migrate-pipelines-toml</code> command to migrate. (Note that this command will be removed in the next release.)</li>
<li><strong>Rendering</strong>: Removing the <code>outline_recursive</code> component from a entity will now remove the outline from its children as well.</li>
<li><strong>API</strong>: The <code>ambient_ui</code> prelude (and the <code>ambient_api</code> prelude, by extension) no longer glob-imports components into the global namespace. This means that you will need to import components explicitly.</li>
<li><strong>Input</strong>: <code>CursorLockGuard</code> no longer takes an initial argument for its lock state. Instead, it will automatically lock and unlock on focus change.</li>
</ul>
<h4 id="non-breaking"><a class="header" href="#non-breaking">Non-breaking</a></h4>
<ul>
<li><strong>Logging</strong>: The logging output levels have been tweaked to better communicate the state of the system at any given time.</li>
<li><strong>Debugger</strong>: The debugger has been improved with a resizable sidebar, a scrollable view, and a component filter.</li>
<li><strong>Animation</strong>: The animation graph is now executed on the server as well.</li>
</ul>
<h3 id="fixed"><a class="header" href="#fixed">Fixed</a></h3>
<ul>
<li><strong>Rendering</strong>: Skinned meshes will no longer be corrupted when there is more than one skinned mesh in a mesh buffer.</li>
<li><strong>UI</strong>: <code>TextEditor</code> will no longer capture input even when it is not visible.</li>
<li><strong>Rendering</strong>: Decals now render more consistently.</li>
<li><strong>API</strong>: <code>entity::wait_for_component</code> will now exit if the entity is despawned.</li>
<li><strong>API</strong>: The <code>message::Source</code> methods no longer consume the source when returning their data.</li>
<li><strong>Rendering</strong>: Lines with a <code>from</code> located after a <code>to</code> on the X-dimension will now render correctly.</li>
<li><strong>API</strong>: The <code>entity::mutate_component</code> documentation now refers to the correct parameter. Thanks to <a href="https://github.com/aldzban">@aldzban</a> for fixing this in <a href="https://github.com/AmbientRun/Ambient/pull/482">#482</a>.</li>
<li><strong>UI</strong>: The <code>ScrollArea</code> now has a scroll bar.</li>
<li><strong>Input</strong>: Input is now cleared when the window loses focus, preventing &quot;stuck input&quot; bugs.</li>
</ul>
<h3 id="community-prs-to-internals"><a class="header" href="#community-prs-to-internals">Community PRs to internals</a></h3>
<p>These PRs are not directly user-facing, but improve the development experience. They're just as appreciated!</p>
<h3 id="changed-1"><a class="header" href="#changed-1">Changed</a></h3>
<ul>
<li><code>glam</code> was updated to 0.24. Thanks to <a href="https://github.com/devjobe">@devjobe</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/434">#434</a>.</li>
</ul>
<h3 id="removed"><a class="header" href="#removed">Removed</a></h3>
<h2 id="version-021-2023-05-06"><a class="header" href="#version-021-2023-05-06">Version 0.2.1 (2023-05-06)</a></h2>
<h3 id="fixed-1"><a class="header" href="#fixed-1">Fixed</a></h3>
<ul>
<li><strong>API</strong>: The API documentation is now built only for the <code>wasm</code> target on <code>docs.rs</code>.</li>
</ul>
<h2 id="version-020-2023-05-05"><a class="header" href="#version-020-2023-05-05">Version 0.2.0 (2023-05-05)</a></h2>
<h3 id="added-1"><a class="header" href="#added-1">Added</a></h3>
<h4 id="headline-features-1"><a class="header" href="#headline-features-1">Headline features</a></h4>
<ul>
<li><strong>API</strong>: Guest code can now <strong>create and interact with UI</strong>. See <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/ui">the UI examples</a>.</li>
<li><strong>API</strong>: Guest code can now <strong>run on the client</strong>. See <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/basics/clientside">the <code>clientside</code> example</a>.</li>
<li><strong>API</strong>: Clientside guest code can now play <strong>basic audio</strong>. See <a href="https://github.com/AmbientRun/Ambient/tree/main/guest/rust/examples/games/pong">the <code>pong</code> example</a>.</li>
<li><strong>Server</strong>: By default, a proxy URL is generated for the server on startup. This can be used to access a running server from anywhere on the internet, making it easy to share your work with others. To turn this off, specify <code>--no-proxy</code> on the server command line.</li>
</ul>
<h4 id="other-1"><a class="header" href="#other-1">Other</a></h4>
<ul>
<li><strong>API</strong>: Kinematic bodies are now exposed. This is used by the minigolf example to provide its moving obstacles.</li>
<li><strong>API</strong>: Added <code>physics::move_character</code> function to correctly move character controllers. This is used by the third-person camera example.</li>
<li><strong>API</strong>: <code>Uvec2</code>/<code>Uvec3</code>/<code>Uvec4</code>/<code>U8</code> can now be used for component values.</li>
<li><strong>API</strong>: A new <code>message</code> API has been added to allow for sending messages between client and server WASM, and from one WASM module to another. Messages are defined in <code>ambient.toml</code> and are structured. Message subscriptions return handles that can be used to cancel their subscriptions.</li>
<li><strong>API</strong>: A new <code>camera</code> API has been added on the client for operations that involve the camera, including <code>screen_ray</code> for calculating a ray from the camera through a screen position. Thanks to <a href="https://github.com/owenpalmer">@owenpalmer</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/316">#316</a>.</li>
<li><strong>API</strong>: A new <code>input</code> API has been added for retrieving input and manipulating the cursor (including changing its icon, visibility and lock state).</li>
<li><strong>API</strong>: <code>physics::{add_impulse, add_force_at_position, add_impulse_at_position, get_velocity_at_position}</code> have been added.</li>
<li><strong>API</strong>: Added <code>create_revolute_joint</code> to the <code>physics</code> API.</li>
<li><strong>API</strong>: Added a capsule concept with corresponding components.</li>
<li><strong>API</strong>: Several animation manipulation functions have been added to <code>entity</code> and <code>asset</code>. Thanks to <a href="https://github.com/devjobe">@devjobe</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/362">#362</a>.</li>
<li><strong>Physics</strong>: A <code>collider_loaded</code> component will now be automatically attached to an entity once its collider has finished loading.</li>
<li><strong>Client</strong>: The client's window title is now automatically changed to the name of the project running on the server. Thanks to <a href="https://github.com/MavethGH">@MavethGH</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/178">#178</a>.</li>
<li><strong>Client</strong>: Added a basic headless mode to enable automatic CI testing of projects.</li>
<li><strong>Client</strong>: Added <code>Dump UI World</code> button to inspect the state of the UI. Thanks to <a href="https://github.com/owenpalmer">@owenpalmer</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/216">#216</a>.</li>
</ul>
<h4 id="examples-2"><a class="header" href="#examples-2">Examples</a></h4>
<ul>
<li>A suite of UI examples have been added to demonstrate how to use the UI in guest code.</li>
<li>The <code>clientside</code> example shows how to use clientside WASM.</li>
<li>The <code>messaging</code> example shows how to message the server from the client and vice versa, and how to message another module with both broadcasts and directed messages.</li>
<li>The <code>pong</code> example implements a basic version of Pong to demonstrate a basic multiplayer game.</li>
<li>The <code>fog</code> example shows how to configure fog in the renderer for more atmospheric scenes.</li>
<li>The <code>first_person_camera</code> example shows how to implement a first-person camera.</li>
<li>The <code>music_sequencer</code> example shows how to use the audio and UI API to build a basic music sequencer.</li>
<li>The <code>decals</code> example shows how to use decals to add detail to a scene. Thanks to <a href="https://github.com/kevzettler">@kevzettler</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/347">#347</a>.</li>
</ul>
<h3 id="changed-2"><a class="header" href="#changed-2">Changed</a></h3>
<h4 id="breaking-1"><a class="header" href="#breaking-1">Breaking</a></h4>
<ul>
<li><strong>Client</strong>: <code>--debug</code> is now <code>--debugger</code>, but it can also be accessed through the <code>AMBIENT_DEBUGGER</code> env variable.</li>
<li><strong>API</strong>: The <code>Cargo.toml</code> has changed to enable clientside builds. Please look at the examples to see how to update your <code>Cargo.toml</code> appropriately.</li>
<li><strong>API</strong>: <code>ChangeQuery</code> has been split into <code>UntrackedChangeQuery</code> and <code>ChangeQuery</code> to ensure that <code>track_change</code> is called before the query is built.</li>
<li><strong>API</strong>: <code>asset_url</code> has moved to <code>asset::url</code>.</li>
<li><strong>API</strong>: <code>EventResult</code> and <code>EventOk</code> have been renamed to <code>ResultEmpty</code> and <code>OkEmpty</code> to better clarify their purpose.</li>
<li><strong>API</strong>: The physics API has been revamped to better encode the physics engine's capabilities.
<ul>
<li><code>physics::apply_force</code> is now <code>physics::add_force</code>.</li>
<li><code>physics::explode_bomb</code> is now <code>physics::add_radial_impulse</code>, and takes a <code>FalloffRadius</code> enum.</li>
</ul>
</li>
<li><strong>API</strong>: All input functionality has moved to <code>input</code> on the clientside.</li>
<li><strong>API</strong>: The <code>lookat_center</code> component has been renamed to <code>lookat_target</code>.</li>
<li><strong>Physics</strong>: Convex shapes are now used if a body is neither static or kinematic.</li>
</ul>
<h4 id="non-breaking-1"><a class="header" href="#non-breaking-1">Non-breaking</a></h4>
<ul>
<li><strong>Ambient</strong>: Ambient is now dual-licensed MIT/Apache2, in accordance with the rest of the Rust ecosystem.</li>
<li><strong>Ambient</strong>: The default logging settings now better communicate what Ambient is doing at any given moment.</li>
<li><strong>Project</strong>: Concept definitions in projects now support namespaces. Thanks to <a href="https://github.com/ArberSephirotheca">@ArberSephirotheca</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/212">#212</a>.</li>
<li><strong>API</strong>: Concepts now include the components they use in their doc comments.</li>
<li><strong>API</strong>: <code>#[main]</code>-attributed functions no longer have to be <code>async</code> or return a <code>Result</code>.</li>
<li><strong>API</strong>: <code>#[main]</code>-attributed functions, <code>on</code>, <code>once</code>, <code>Query::bind</code> and <code>run_async</code> can now return a <code>Result</code> or nothing.</li>
<li><strong>Project</strong>: Project manifests can now be split into multiple files using <code>includes</code>.</li>
</ul>
<h3 id="fixed-2"><a class="header" href="#fixed-2">Fixed</a></h3>
<ul>
<li><strong>Ambient</strong>: Various stability and performance fixes.</li>
<li><strong>Ambient</strong>: Added attributions for external code.</li>
<li><strong>Ambient</strong>: Typo fixes. Thanks for the following!
<ul>
<li><a href="https://github.com/AmbientRun/Ambient/pull/159">#159: fix: docs broken links to gh-pages</a> by <a href="https://github.com/daniellavoie">@daniellavoie</a></li>
<li><a href="https://github.com/AmbientRun/Ambient/pull/172">#172: chore: fix typo in gpu.rs</a> by <a href="https://github.com/eltociear">@eltociear</a></li>
</ul>
</li>
<li><strong>Examples</strong>: The Minigolf example now has several gameplay tweaks (including camera movement on right-click) to improve the experience.</li>
<li><strong>Examples</strong>: The examples no longer occasionally use non-one alpha colours, which led to them rendering black objects.</li>
<li><strong>Server</strong>: The server no longer shuts down automatically after a period of inactivity.</li>
<li><strong>ECS</strong>: A bug with ECS component versioning that led to certain components not updating has been fixed. Fixes <a href="https://github.com/AmbientRun/Ambient/issues/113">#113</a>.</li>
<li><strong>Networking</strong>: Various optimizations have been made to networking and the ECS to reduce unnecessary network traffic.</li>
</ul>
<h3 id="community-prs-to-internals-1"><a class="header" href="#community-prs-to-internals-1">Community PRs to internals</a></h3>
<p>These PRs are not directly user-facing, but improve the development experience. They're just as appreciated!</p>
<ul>
<li><strong>CI</strong>: Linux CI builds now output the tree of their target to assist in debugging CI cache blow-up. Thanks to <a href="https://github.com/daniellavoie">@daniellavoie</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/170">#170</a>.</li>
<li><strong>ECS</strong>: <code>Entity::assert_all</code> can be used to ensure all components for an <code>Entity</code> on the host have an attribute. Thanks to <a href="https://github.com/MavethGH">@MavethGH</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/211">#211</a>.</li>
<li><strong>App</strong>: <code>ambient new</code> uses the correct path for relative API when creating a project in <code>guest/rust/examples</code>. Thanks to <a href="https://github.com/owenpalmer">@owenpalmer</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/218">#218</a>.</li>
<li><strong>Ambient</strong>: The presentation of the license in the repository was improved. Thanks to <a href="https://github.com/C-BJ">@C-BJ</a> for <a href="https://github.com/AmbientRun/Ambient/pull/201">#201</a> and <a href="https://github.com/AmbientRun/Ambient/pull/203">#203</a>.</li>
<li><strong>Ambient</strong>: The book and build CI workflows now only run when relevant files are updated. Thanks to <a href="https://github.com/C-BJ">@C-BJ</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/202">#202</a>.</li>
<li><strong>Audio</strong>: The audio asset pipeline now uses Rust libraries for re-encoding files, instead of shelling out to ffmpeg. Thanks to <a href="https://github.com/marceline-cramer">@marceline-cramer</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/317">#317</a>.</li>
<li><strong>Rendering</strong>: Ambient now runs on wgpu 0.16, improving compatibility and providing access to new features. Thanks to <a href="https://github.com/kevzettler">@kevzettler</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/308">#308</a>.</li>
<li><strong>Campfire</strong>: The internal development tool Campfire can now automatically check release-readiness. Thanks to <a href="https://github.com/kevzettler">@kevzettler</a> for implementing this in <a href="https://github.com/AmbientRun/Ambient/pull/356">#356</a>.</li>
</ul>
<h3 id="removed-1"><a class="header" href="#removed-1">Removed</a></h3>
<ul>
<li><strong>API</strong>: <code>player_camera</code> has been removed, and the components it instantiated are now directly exposed. See the <code>multiplayer</code> example to see what's changed.</li>
<li><strong>API</strong>: Events have been removed and replaced with the more general-purpose <code>message</code> API.</li>
</ul>
<h2 id="version-011-2023-02-22"><a class="header" href="#version-011-2023-02-22">Version 0.1.1 (2023-02-22)</a></h2>
<h3 id="added-2"><a class="header" href="#added-2">Added</a></h3>
<ul>
<li>A <a href="community/guest/rust/examples/minigolf">minigolf example</a> by <a href="https://github.com/SK83RJOSH">SK83RJOSH</a>.</li>
<li>Examples are now bundled into a downloadable <code>examples.zip</code> for each release.</li>
</ul>
<h3 id="fixed-3"><a class="header" href="#fixed-3">Fixed</a></h3>
<ul>
<li>macOS ARM64 builds are now available after enabling the execution of unsigned executable memory (as required for wasmtime execution).</li>
<li>The debugging configuration for VSCode was updated to use the new CLI.</li>
<li>Minor documentation updates.</li>
</ul>
<h2 id="version-010-2023-02-22"><a class="header" href="#version-010-2023-02-22">Version 0.1.0 (2023-02-22)</a></h2>
<p>Initial release. See the <a href="https://www.ambient.run/post/introducing-ambient">announcement blog post</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
